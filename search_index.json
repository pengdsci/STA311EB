[["index.html", "STA311: Stats Comp. &amp; Data Mgmt. Chapter 1 Introduction", " STA311: Stats Comp. &amp; Data Mgmt. Cheng Peng West Chester University Chapter 1 Introduction This is a E-Pack book written in Markdown through bookdown package. The E-Pack contains the topics covered in STA311 at WCU. STA311 Statistical Computing and Data Management is an introductory SAS programming course. The course will give students the ability to manage and manipulate data effectively, conduct basic statistical analysis, and generate reports and graphics primarily using the SAS Statistical Software Program. SAS system has been the major system for statistical analysis and data processing for many years. It is still widely used in industries, particularly in the pharmaceutical and financial fields. Since it has been in the field for many years, there are a lot of resources available. This is good for experienced SAS users, but it could be a challenge for beginners. This note focuses on the fundamentals of SAS programming and data processing techniques. The objective of this note is to introduce SAS system and the structure of SAS as a script programming language. Syntax and conventions in SAS How SAS works in data manipulations Functioning of DATA and PROC steps in SAS programming SAS data input and output Programming basics including flow control and arrays Basic MACRO: structure and usage Basic descriptive statistics with SAS including basic SAS graphics. The coverage will be similar to the contents required in the Base SAS Programming Certification. "],["basics-of-sas-system.html", "Chapter 2 Basics of SAS System 2.1 SAS Data and Variables 2.2 SAS Code Structure 2.3 SAS Libraries 2.4 First SAS Code: “Hello World!” 2.5 SAS Log Files 2.6 SAS Output 2.7 Some SAS Tutorial from SAS Inc.", " Chapter 2 Basics of SAS System This chapter introduces the basics of the SAS system. Figure 2.1: SAS use graphic interface. Log Window: It is an execution window. Here, you can check the execution of your program. It also displays errors, warnings, and notes. Code Window: This window is also known as the editor window. Consider it as a blank paper or a notepad, where you can write your SAS code. Output Window: As the name suggests, this window displays the output of the program/ code that you write in the editor. Result Window: It is an index that lists all the outputs of programs that are run in one session. Since it holds the results of a particular session, if you close the software and restart it, the result window will be empty. 2.1 SAS Data and Variables SAS data sets are also called SAS data files. A SAS data set has rows and columns. When other formats of data files such as .csv, .txt, .xls, etc., were loaded to SAS, they were converted to the SAS format data file with the extension .sas7bdat. SAS has two basic types of variables: numerical variable and character variable. Numerical variable is the default type of variable in SAS. Mathematical expressions use numerical variables in data processing. Character variables are those that are not used in mathematical expressions in variable processing. Numerical variables can be converted into character variables if needed. But not the opposite unless the character variables are numerically encoded. 2.2 SAS Code Structure SAS programming is based on two building blocks DATA Step: The DATA step creates a SAS data set and then passes the data onto a PROC step PROC Step: The PROC step processes the data An SAS program should follow below mentioned rules Almost every code will begin with either DATA or a PROC Step. Every SAS statement ends with a semi-colon. A SAS step ends with either RUN or QUIT. SAS codes are not case-sensitive. We can write a SAS statement across different lines or you can write multiple statements in one line. 2.3 SAS Libraries SAS library is a collection of SAS data files that are stored in the same folder or directory on your computer or other storage such as a USB drive or a space in the cloud. Temporary Library: In this library, the data set gets deleted when the SAS session ends. Permanent Library: Data sets are saved permanently. Hence, they can be accessed in future SAS sessions. Users can also create or define a new library known as user user-defined library by using the keyword LIBNAME. These are also permanent libraries. 2.4 First SAS Code: “Hello World!” Beginners usually start their coding with Hello World!'. The SASHello World` is given below. /************************************* My First SAS Program Author: C. Peng Date: 08/22/2020 Topics: 1. Data Step 2. Procedure Step ***************************************/ /* Data Step: Create a SAS dataset with one variable */ DATA work.HelloWorld; /* libname.datasetName */ my1stSAScode = &quot;Hello World&quot;; RUN; /* Procedure step: print out the SAS dataset */ PROC PRINT DATA = work.HelloWorld; RUN; The above example code involves code header (information about the code), /* SAS comments (usually multiple line comments) */ Important Notes SAS is NOT case-sensitive! This is very different from some other case-sensitive language. When we name a variable, VaRible and vaRiBlE are identical in SAS. A complete SAS code line MUST closed with a semi-colon (;)! Each DATA step and PROC step MUST be closed with key word RUN to tell the SAS system to execute the DATA or PROC step. 2.5 SAS Log Files Each time a step is executed in a SAS program, SAS generates a log file. The SAS log collects messages about the processing of SAS programs and any errors that might occur. If the SAS code contains an error, the error will also be printed in the SAS log file. Figure 2.2: SAS use graphic interface. 2.6 SAS Output In addition to the traditional line output, the SAS 9.4 and later version allows different formats of output such as PDF, HTML, and WORD. The following screenshot shows the step of choosing HTML output. Figure 2.3: Choosing SAS output formats. 2.7 Some SAS Tutorial from SAS Inc. 2.7.1 Description of the SAS Program 2.7.2 SAS Graphical User Interface 2.7.3 Writing SAS Code "],["coding-conventions-and-best-practices.html", "Chapter 3 Coding Conventions and Best Practices 3.1 SAS file and Program Structures 3.2 Naming Conventions and SAS Program Structure 3.3 SAS Data Structure 3.4 Some Best Coding Practices 3.5 Learning SAS Coding by Examples", " Chapter 3 Coding Conventions and Best Practices This chapetr discuss best practices and conventions in SAS programming. Some of the concepts covered in the previous chapter will be reviewed with more details. 3.1 SAS file and Program Structures SAS data files are stored in a SAS library that is a folder in the directory. Figure 3.1: Structure of a SAS library. There several types of libraries in the SAS system. Temporary libraries, SAS system defined permanent libraries, and user defined permanent libraries. All data files stored in the temporary library (library reference name: work.) will be wiped out from the temporary library. All data files stored in the permanent libraries can be re-used in the future SAS sessions. Figure 3.2: Different SAS libraries. When we submit the LIBNAME statement, a connection is made between a libref in SAS and the physical location of files on the operating system. Figure 3.3: Naming convention of SAS library reference name. 3.2 Naming Conventions and SAS Program Structure Every language has its own naming conventions. The following are naming conventions in SAS programming. Every SAS statement ends in a semicolon (;)!!!!!!!! All variable and data set names must start with a letter or an underscore (_). Names can contain only letters, numerals, and the underscore. No %$!*&amp;#@. SAS is case insensitive (e.g Body, body, boDY and BoDy are all the same name to SAS). There are no restrictions on where in the line statements start or stop and commands may be wrapped onto multiple lines. All variable and data set names must be thirty-two (32) or fewer characters in length (8 characters in SAS V6.12 or lower). The names _N_, _ERROR_, _FILE_, _INFILE_, _MSG_, _IORC_, and _CMD_ are reserved for the variables that are generated automatically for a DATA step. Note that SAS products use variable names that start and end with an underscore; it is recommended that we do not use names that start and end with an underscore in SAS programming. SAS programs (scripts) are composed of DATA block and ROCedure Blocks. Figure 3.4: Naming convention of SAS library reference name. DATA block consists of SAS statements telling the application what to do with the data set (e.g, input formats, variable names, create new variables, etc.) PROC block consists of SAS statements telling the applications what to do to the data set (e.g, print it out, create a cross-tabulation table, perform computations for a statistical analysis. Figure 3.5: SAS code blocks (structure). After we ran the code, we should always check the log window for potential errors, warning messages, etc. before check the result window (line output) and justify the result. The following the screenshot illustrates the process. Figure 3.6: Basic SAS debugging process. 3.3 SAS Data Structure A SAS data set has two components: descriptor portion and data portion. The descriptor portion of a SAS data set contains general information about the SAS data set (such as data set name and number of observations) variable attributes (name, type, length, position, informat, format, label). We can use PROC CONTENTS to view the information in the data descriptor. We can add this type of information when we define a SAS data set. The formation of formats and informats of SAS variables is carried in the data set. We next briefly describe the concepts of formats and informats: Informats is used to tell SAS how to read a variable whereas Formats is used to tell SAS how to display or write values of a variable. Informats is basically used when you read or import data from either an external file (Text/Excel/CSV) or read in sample data which was created using CARDS/DATALINES statement. It is also used when you create a new variable in a data set. Formats can be used in both DATA Steps and PROC Steps whereas Informat can be used only in DATA Steps. 3.4 Some Best Coding Practices The following are some best practices you should always have in mind when you make a program Write a clear program header; Write comments and documentation; Use consistent indentation; Don’t repeat yourself (aka DRY principle); Avoid deep nesting; Limit line length; Set up a simple and clear file and folder structure; Follow naming convention; Keep the code simple! Save the code a version number – version control; Never modify the source data!!! 3.5 Learning SAS Coding by Examples /****************************************************** Author: C. Peng Date: 02/01/2021 Updates: Fall 2020, Spring 2021 Topics: Examples Illustrating the Following Concepts 1. Program header; 2. Display control; 3. SAS display management: DM-statement 4. SAS library - file/folder structure; 5. Data Step and Procedure Step; 6. Commenting and documentation; 7. Conventions and naming rules; 8. Debugging code - understand SAS log; 9. Find SAS dataset structure: descriptor and data block **********************************************/ *OOOOOOOOOOOOOOOOO; ** Topic 1; *OOOOOOOOOOOOOOOOO; /* Display management: clear log and output The following DM statement will automatically delete the content in the designated window! */ DM &quot;CLEAR LOG&quot;; DM &quot;CLEAR OUT&quot;; *OOOOOOOOOOOOOOOOOOO; ** Topic 2; *OOOOOOOOOOOOOOOOOOO; ************************************************* Set up a SAS library and save the created SAS dataset to the local computer - SAS permanent data **************************************************; LIBNAME sta311 &quot;I:\\Desktop\\cpeng\\WCU-Teaching\\2020Fall\\STA311\\SAS&quot;; *NOTE: if you have SAS installed on your own computer, the path in the libname statement should be: LIBNAME sta311 &quot;C:\\STA311\\Fall2020&quot;; *OOOOOOOOOOOOOOOOOO; ** Topic 3; *OOOOOOOOOOOOOOOOOO; /************************************************************** Display control: SAS system OPTIONS There many options avaialble in SAS that can be found by typing PROC OPTIONS; RUN; Most commonly used options are: pagesize, linesize, date, nodate, number, nonumber, etc. See SAS document for explanantions of these commonly used options: https://documentation.sas.com/?docsetId=basess&amp;docsetTarget=n1km315k2himgpn1j6d82y0yju4v.htm&amp;docsetVersion=9.4&amp;locale=en ***************************************************************/ OPTIONS PS = 100 /* page size of log and output (listing) */ LS = 90 /* line size of log and output (listing) */ NODATE /* turn off the date option in listing window */ NONUMBER; /* SAS will not print page numbers in the output window */ *OOOOOOOOOOOOOOOOO; ** Topic 4; *OOOOOOOOOOOOOOOOO; /********************************************* DATA step statements One way to create SAS dataset is to use DATA step statement. There are several different ways to read data in different formats. We will introduce the three most commonly used methods: column, list, and formatted methods. The following DATA step uses the column input. Components of a DATA STEP: DATA statement; INPUT statement; DATALINES (CARDS); data block ; RUN statement; The different input styles determine the types of input. The detailed information can be found at https://documentation.sas.com/?docsetId=lestmtsref&amp;docsetTarget=n0oaql83drile0n141pdacojq97s.htm&amp;docsetVersion=9.4&amp;locale=en#p0ert9pwdtsq4en1czu9tcrncgm8 Column input illustration: ----+----1----+----2----+----3---- Florida 130 90 **********************************************/ /* This data step uses COLUMN INPUT style, More examples and explanations will be given in the next few weeks. */ DATA Orange; /* send the SAS data set to the temporary library */ INPUT state $ 1-10 early 12-14 late 16-18; /* SAS has two basic types of data: numeric and categorical. $ is used to specify categorical data. As an example, we look at variable state: $ indicates that state is a categorical variable. 1-10: all characters including white space in the first column define a string. That string is the value of the categorical variable STATE. */ /* DATALINES - tells SAS the data block begins. we can also use CARDS instead. CARDS was used in the old version of SAS. */ DATALINES; Florida 130 90 California 37 26 Texas 1.3 .15 Arizona .65 .85 ; /* this semi-colon is required! SAS will wait for the next line of data until &quot;seen&quot; this semi-colon.*/ RUN; /* This is optional, but it is always a good idea to close this DATA STEP with this RUN; statement. */ /* Follow the steps to see where this data SAS data resides: go to the Explore window -&gt; Libraries -&gt; Work -&gt; Orange */ *OOOOOOOOOOOOOOOOOO; ** Topic 5; *OOOOOOOOOOOOOOOOOO; /****************************************************** A simplest SAS Procedure syntax: PROC keyword DATA = datasetname; the specific task to perform on a SAS data set; RUN; Next, we print out the SAS data set created from the above DATA STEP *******************************************************/ PROC PRINT DATA = Orange; /* PRINT &lt;- keyword, DATA &lt;- dataset in the trmporary library */ TITLE1 &quot;This is a toy data set&quot;; TITLE2 &quot;Orange&quot;; RUN; /* After you run this block of code, you will see the data set in a browser (html) and the output window (if it is selected). */ ** Topic 6. SAS data structure: descriptor; /* We can find descriptor of as SAS data set by using PROC CONTENTS */ PROC CONTENTS DATA = ORANGE; /* display the contents in the output windows */ RUN; /* Remarks: The default length for a numeric variable is 8 bytes. The length of a character variable is set at the first occurrence of the variable. The following data step is called LIST INPUT. More examples and details will be given in the next few weeks. */ DATA Orange_02; /* send the SAS data set to the temporary library */ INPUT state $ early late ; DATALINES; California 37 26 Florida 130 90 Texas 1.3 .15 Arizona .65 .85 ; RUN; PROC PRINT DATA = ORANGE_02; TITLE1 &quot;List input style&quot;; TITLE2 &quot;Orange 02&quot;; RUN; TITLE &quot;&quot;; PROC CONTENTS DATA = ORANGE_02; /* display the contents in the output windows */ RUN; /* You can check them out from the Results windows: */ /*OOOOOOOOOOOOOOOOOOOOOOOOO Summary OOOOOOOOOOOOOOOOOOOOOOOOOOO 1. A good program should have an informative program header. 2. Define a library to store your SAS data sets. 3. Set options to produce nice-looking outputs. 4. Commenting on your program to make it clear and understandable. 5. DATA step creates and/or modifies SAS data sets. 6. PROC step performs specific tasks on SAS data. Next time, we still use column input to define the data set and add a few more ingredients in both the data step and procedure step to make better SAS programs. *******************************/ "],["methods-of-sas-data-input.html", "Chapter 4 Methods of SAS Data Input 4.1 Specifying Variable Length 4.2 Methods of Data Input 4.3 Handling Special Structured Data 4.4 Making Better Line Outputs 4.5 Learning SAS Coding by Examples", " Chapter 4 Methods of SAS Data Input Before we introduce SAS input methods, we first review the basic concepts introduced previously. SAS Data Set - a binary formatted representation of the input data set stored in such a way that future SAS programs do not need to input the data again. Temporary SAS Data Sets - created and remain in working memory for the SAS session, but disappear when the SAS session ends. It is fine for small to moderate-sized, simple input programs. Permanent SAS Data Sets - created in one SAS session but stored on disk for later reuse. It is convenient for large or complex input data sets that may require multiple analysis steps. It reduces time and computer resources. LIBNAME statement - identifies the SAS program where the previously created SAS data set is located. Use of Comments - to make the code easy to understand. The purpose of comments is To note the history of your analysis. Keep track of the steps you took to create the data set. Keep track of data modifications. Keep track of all statistical analyses attempted. Assist others in understanding your analysis. To block out sections of the program ( /* and */) allowing you to run partial analyses but return to previous analyses if you change your approach. To refresh your memory about the project you have to return to the analysis to answer questions from Journal reviewers, academic advisers, and colleagues, months or years after the data have been analyzed. 4.1 Specifying Variable Length One of the important pieces of information in data input is to specify the length of each input variable. This is also one of the sources of common errors in data input. Here is some important information about the lengths of SAS variables. The default length for character and numeric variables is 8 bytes in SAS. SAS uses exactly one byte for one character! This means that if the value of a character variable has more than 8 characters, SAS only keeps the first 8 characters (including the white space if any) and truncates the rest. However, for a numeric variable SAS variable, 8 bytes can store a number with up to 16 digits. In other words, the default length of a numeric variable is 16 digits. It is important to note that the minimum length of a numeric is 3 bytes. It does not mean it cannot store a numeric value lower than 3 digits. It can store values of 1 or 2 digits. The maximum length of any character value in SAS is 32,767 bytes! Specifying the length of variables Variable lengths specified in a LENGTH statement affect the length of numeric variables only in the output data set; during processing, all numeric variables have a length of 8 bytes. Lengths of character variables specified in a LENGTH statement affect both the length during processing and the length in the output data set. Figure 4.1: Specifying length of input variables. Don’t forget to use the dollar sign $ when specifying the length of a character variable. See the following figure. Figure 4.2: Caution about specifying length of character variables.. 4.2 Methods of Data Input Three basic input styles in SAS are illustrated in the following figures. 4.2.1 List Input The input data values are simple and the default length of variables are used. Dollar signs are also used to specify the character variables in the data set. Figure 4.3: SAS data input styles. When data columns are not lined up, use list input. Make sure, the data file has the following features At least one blank between values of adjacent variables; No white space (blanks) within data values; For example, Mary Beth has a white space in the character value, and list input should not be used. Character data values must be less than or equal to 6 characters. The above code includes the input data file in the program (also called inline input). DATALINES or CARDS statement is used for all inline input. When the input data file is a data file in a physical location in a drive, INFILE statement must be used. 4.2.2 Column Input With column pointers, we can tell SAS directly which column to begin reading a variable from. Go directly to the information you really need. Skip unnecessary information. Efficient data entry The following figure shows column input with an external file. Figure 4.4: Column input with an external data file. 4.2.3 Formatted Input (Delimited Input) The fundamental difference between column input, which we studied in the previous lesson, and formatted input, which we’ll explore now, is that column input is only appropriate for reading standard numeric data, while formatted input allows us to read both standard and nonstandard numeric data. That is, formatted input combines the features of column input with the ability to read nonstandard data values including values that contain special characters, such as dollar signs ($), percent signs (%), and commas (,) date and time values data in fraction, integer binary, real binary, and hexadecimal forms Figure 4.5: Delimited (formatted) input. 4.2.4 Summary - Three Input Styles Figure 4.6: SAS data input styles. 4.2.5 Mixed Input SAS also allows mixed input. The following figure gives an example that involves mixed input styles. Figure 4.7: Mixed input style. 4.3 Handling Special Structured Data Sometimes, the input data files may have different structures, we need special handling of these types of data layouts. 4.3.1 Data File Containing Comments and Descriptions We can use keywords FIRSTOBS = and Figure 4.8: Data file with descriptions and comments. 4.3.2 Multi-line for the Record Data may come to us with each observation recorded on more than one line. We need to be able to tell SAS to go to the next line. SAS can do the trick in two different ways. The slash (/) says to skip to the next line. The code #n says go to that line of the observations data to resume reading data. Figure 4.9: Reading in multi-line records. 4.3.3 Multi-records In the Same Line In case situations, we may have data sets in which a single line may have multiple records. In SAS. trailing “at” symbols ( @@ ) tells SAS to hold the current data line for further information. Read in name–absences then hold the current position on the data line. Read in another set of names–absences then hold position. Keep doing this until an end-of-line marker is reached. The next data step gives an example of this type of data. DATA grades; INPUT name $ quiz test project $ absences @@; DATALINES; Ann 84 90 A- 0 Bill 78 84 B 0 Cathy 95 89 A 1 David 84 88 B+ 1 ; RUN; 4.4 Making Better Line Outputs We view the results line output window frequently in analysis. There are different ways that we can use to make the output better looking and more informative. 4.4.1 OPTIONS Statement OPTIONS Statement is placed at the beginning of the program to control output options. It remains in effect until you change it. The commonly used options are given in the following figure. Figure 4.10: Global options of output. 4.4.2 Titles and Footnotes Use a TITLE and/or FOOTNOTE statement to place comment information at the top (TITLE) or bottom (FOOTNOTE) of each output page. Once set, TITLE and FOOTNOTE information will be printed for each procedure output unless a new TITLE or FOOTNOTE statement is encountered. Figure 4.11: Titles and footnotes. 4.4.3 Labeling Variables We use the label statement in the data step to assign labels to the variables. We could also assign labels to variables in proc steps, but then the labels only exist for that step. When labels are assigned in the data step they are available for all procedures that use that data set. To explain, we first define a data set. DATA auto ; INPUT make $ mpg rep78 weight foreign ; DATALINES; AMC 22 3 2930 0 AMC 22 . 2640 0 Audi 17 5 2830 1 Audi 23 3 2070 1 BMW 25 4 2650 1 Buick 26 . 2230 0 Buick 19 3 3400 0 Cad. 14 3 4330 0 Cad. 14 2 3900 0 Cad. 21 3 4290 0 Chev. 29 3 2110 0 Chev. 19 3 3430 0 Datsun 23 4 2370 1 Datsun 35 5 2020 1 ; RUN; The following program assigns variable labels to rep78, mpg, and foreign. DATA auto2; SET auto; LABEL rep78 =&quot;1978 Repair Record&quot; mpg =&quot;Miles Per Gallon&quot; foreign=&quot;Where Car Was Made&quot;; RUN; You can see the labels in the PROC CONTENTS procedure. 4.4.4 Formats and User Define Formats Sometimes, people also consider labels as a kind of format. SAS has many different formats for special variables, for example, SAS date formats. SAS also allows users to define formats. The next example shows how to define formats for variables. PROC FORMAT; VALUE forgnf 0=&quot;domestic&quot; 1=&quot;foreign&quot; ; VALUE $makef &quot;AMC&quot; =&quot;American Motors&quot; &quot;Buick&quot; =&quot;Buick (GM)&quot; &quot;Cad.&quot; =&quot;Cadillac (GM)&quot; &quot;Chev.&quot; =&quot;Chevrolet (GM)&quot; &quot;Datsun&quot; =&quot;Datsun (Nissan)&quot;; RUN; It should be noted that a dollar sign $ must be used when defining a format for a character variable! Once a format of a variable is defined, it will be used the same way as other built-in formats in SAS to make better output. 4.4.5 A Note on SAS Dates SAS dates are complex in format. We will not discuss this systematically here. When the SAS date is a numerical variable, its value is the number of days since 1/1/1960. That is, 1/1/1960 00:00:00 is set as ZERO. Figure 4.12: Determination of SAS date values. 4.5 Learning SAS Coding by Examples This section gives several examples of SAS code with comments on some coding specifics. /******************************************************************************* Topics: 1. Review: SAS display management, library, options, permanent/temporary data set 2. SAS INPUT styles: column input, list input, formatted input; 3. Variable LENGTH specification 4. INFILE - reading external data file 5. SAS Labels 6. SAS informat/format *******************************************************************************/ /********************************** 1. Review: Options, LIBNAME, DM ***********************************/ OPTIONS NODATE NONUMBER PS = 80 LS = 64 nodate nonumber; * to specify the form of sas output; LIBNAME sasw03 &#39;C:\\STA311\\w03&#39;; * permenent library; /* clear log and output windows */ DM &#39;CLEAR LOG&#39;; DM &#39;CLEAR OUTPUT&#39;; /*************************************************** 2. SAS INPUT styles: column, list, and formats ****************************************************/ /* 2.1. column input with inline data - values of variables must be placed within the corresponding range and values of adjacent variables must separated by at least one blank. */ DATA Orange; INPUT state $ 1-10 early 12-14 late 16-18; DATALINES; Florida 130 90 California 37 26 Texas 1.3 .15 Arizona .65 .85 ; RUN; PROC PRINT DATA = Orange; TITLE &quot;Output of the testing Data&quot;; RUN; /**------- key takeaways ------- 1. flag character variable with $ 2. INPUT statement: Specify variable type and length. 3. TITLE is a global statement. To delete the previous title, use statement TITLE &quot;&quot;; 4. TITLE can be placed either inside PROC or outside PROC. ---------------------------*/ /* 2.2. List input */ DM &#39;CLEAR LOG&#39;; DM &#39;CLEAR OUTPUT&#39;; /* List input - No blanks between the values of character variables values between adjacent variables must be separated by at least one blank. */ DATA Orange_list; LENGTH state $ 10.; INPUT state $ early late; DATALINES; Florida 130 90 California 37 26 Texas 1.3 .15 Arizona .65 .85 ; RUN; PROC PRINT DATA = orange_list; TITLE &#39;Include data values in the sas program&#39;; RUN; /*--------- Key Takeaways ---------------------------------------------------------------- 1. A list is appropriate when no blanks are in the values of the character variable. 2. If the maximum length of the character variable value is bigger than 8 (i.e., more than 8 characters including blanks BETWEEN the strings, we need to define the length of the variable using the statement: LENGTH char_name $ specified-length 3. One can also specify the length within the INPUT statement: char_name $ specificed_length. Example, INPUT State_name $ 18.; --------------------------------------------------------------------------------------------*/ /******************************************************** 2.3. column pointer-formatted input - values of all variables must be placed within the corresponding column range. There is NO need to separate the values of adjacent variables in column pointer input. **********************************************************/ DM &#39;CLEAR LOG&#39;; DM &#39;CLEAR OUTPUT&#39;; DATA kids; INPUT @1 firstnam $ 11. /* @ &lt;== column pointer */ @12 lastname $11. /* $ &lt;== char variable indicator */ @23 birthday $10. /* in $10, 10 &lt;== length of birthday */ @ 33 gender $1. /* @33 33 &lt;== value of gender starts at column 33 */ @34 wklyrate; /* close the INPUT statement with a semi-colon. */ DATALINES; Douglas Lindgren 08/29/1996M115 Elizabeth Wilkerson 01/13/1997F95 Evangeline Chambers 03/11/1997F100 Arthur Hollander 07/19/1996M. ChristopherKalbfleisch04/13/1995M115 Stacy Siegel 11/15/1996F100 ; RUN; PROC PRINT DATA =kids; TITLE &#39;Daycare roster&#39;; RUN; /*-------------------- Key Takeaways ------------------- 1. In INPUT statement, a column pointer must be placed in front of the corresponding variable. 2. length-specifier: $20 and $ 20 both work fine! 3. column pointer: @33 and @ 33 both work fine! ---------------------------------------------------------*/ /****************************************************************** 3. INFILE - specify whether part of whole of an inline external data file should be read into SAS. *******************************************************************/ DM &#39;CLEAR LOG&#39;; DM &#39;CLEAR OUTPUT&#39;; LIBNAME sasw03 &#39;C:\\STA311\\w03&#39;; * permenent library; /* 3.1 read in part of an external data file */ DATA sasw03.Orange; INFILE &quot;C:\\STA311\\w03\\w03-Orange.txt&quot; FIRSTOBS = 3 OBS = 6; /* use the explicit path, not library reference, The input data is NOT as SAS format data set!*/ INPUT state $ 1-10 early 12-14 late 16-18; RUN; /*--------------- Key Takeaways ------------------- 1. FIRSTOBS = 3: &lt;== Start reading data from row 3. (The first 2 rows contain data descriptions) 2. OBS = 6: &lt;== the last row to read in SAS. (The rest of the rows are part of the data file). 3. INPUT is used as usual to tell the information of the variables! 4. INFILE statement tells the location of the data file. For an external file, the path to the file must be given. FIRSTOBS and OBS are optional. ----------------------------------------------------*/ PROC PRINT DATA = sasw03.Orange; TITLE &#39;Read in data from an external data file&#39;; RUN; QUIT; DM &#39;CLEAR LOG&#39;; DM &#39;CLEAR OUTPUT&#39;; /* 3.2. inline text data with descriptions - read part of the data file: FIRSTOBS= OBS = */ DATA Inline_Orange; INFILE DATALINES FIRSTOBS = 3 OBS = 6; INPUT state $ 1-10 early 12-14 late 16-18; DATALINES; Projected Orange Yields in October 1997 State Early Late Florida 130 90 California 37 26 Texas 1.3 .15 Arizona .65 .85 Based on information obtained from the Florida Agricultural Statistics Service RUN; PROC PRINT DATA =Inline_Orange; TITLE &#39;Read in data from an inline data file&#39;; RUN; QUIT; /*------------------ Key Takeaways ---------------- 1. DATALINES in the INFILE statement points to the location of the inline data file which is below the DATALINES statement. 2. INPUT statement specifies the information of variables as usual regardless of using an inline data file or an external data file. ----------------------------------------------------*/ /***************************************************************************** 4. Complex data layout: (1). The single record was split into multiple lines; (2). Multiple records were put in the sample line. *******************************************************************************/ DM &#39;CLEAR LOG&#39;; DM &#39;CLEAR OUTPUT&#39;; /** 4.1 Read in specially layout data: one record in multiple lines In the old version of SAS, we need to use &#39;\\&#39; or &#39;#2&#39; to tell SAS to continue to read data in the next row. In 9.0 or later, SAS automatically will go to the next line to read data until completing the record. **/ DATA inline_grades_multi_line; INPUT NAME $ / QUIZ TEST PROJECT $ ABSENCES; DATALINES; Ann 84 90 A- 0 Bill 78 84 B 0 Cathy 95 89 A 1 David 84 88 B+ 1 ; RUN; PROC PRINT DATA = inline_grades_multi_line; RUN; /*** 4.2. External txt file - one record in multiple lines ***/ DATA grades_multi_line01; INFILE &quot;C:\\STA311\\w03\\w03-multi-line-grades.txt&quot;; INPUT NAME $ / QUIZ TEST PROJECT $ ABSENCES; RUN; PROC PRINT; RUN; /* If the data set is not specified, PROC PRINT will print the most currently created SAS data set! */ DM &#39;CLEAR LOG&#39;; DM &#39;CLEAR OUTPUT&#39;; /** 4.3. Multiple records in one line: double trailings: @@ must be used as in the following to read the data correctly in SAS. **/ DATA grades_multiple_obs; INPUT name $ quiz test project $ absences; DATALINES; Ann 84 90 A- 0 Bill 78 84 B 0 Cathy 95 89 A 1 David 84 88 B+ 1 ; RUN; PROC PRINT; RUN; DM &#39;CLEAR LOG&#39;; DM &#39;CLEAR OUTPUT&#39;; /* INFILE-DATALINES combination ; */ /* 4.4. It will create a wrong data set if &#39;@@&#39; is used! */ DATA grades_infile_dataline; INFILE DATALINES; INPUT name $ quiz test project $ absences; DATALINES; Ann 84 90 A- 0 Bill 78 84 B 0 Cathy 95 89 A 1 David 84 88 B+ 1 ; RUN; TITLE &quot; grades_infile_dataline;&quot;; PROC PRINT; RUN; TITLE &quot;&quot;; /*------------------ Key Takeaways ---------------------------- 1. The types of errors that SAS log reports are related to syntax. However, seeing no error in the log window does not mean you created a correct data set! You need to the content of the DATA SET before moving to the next step. 2. When you create multiple data sets, add a meaningful title PROC PRINT step so you can see the clear title in each output. It is a good practice to CLEAR the old title for the next new title by typing TITLE &quot;&quot;; after the PROC PRINT step. ----------------------------------------------------------------*/ /* ===================================================== 5. Review: SAS Permanent SAS library - create a permanent SAS library to store SAS *data set*!!! Caution - you can save your SAS file to the folder you used for the SAS library without using library reference!! ========================================================= */ DM &#39;CLEAR LOG&#39;; DM &#39;CLEAR OUTPUT&#39;; LIBNAME SASWK3 &#39;C:\\STA311\\w03&#39;; /* Create a folder under C drive and use the environment shortcut to search the folder, the actual PATH to the folder shown on the top-left of the Explorer window. You need to type the path inside the single quote&#39;&#39; to define the permanent library. */ /** 5.1 Save the created SAS data set to the permanent SAS library **/ DATA SASWK3.libname_orage; LENGTH state $ 10.; INPUT state $ early late; DATALINES; Florida 130 90 California 37 26 Texas 1.3 .15 Arizona .65 .85 ; RUN; PROC PRINT DATA = SASWK3.libname_orage; TITLE &#39;Print the libname_ permanent data set&#39;; RUN; /* ==================================================== 6. Label and Informat/Format It is very important to attach as much information as possible to the variables. Useful information includes - LABEL: a description or definition of variables in the SAS data set. - INFORMAT: Tell SAS the format of the input variables - FORMAT: Tell SAS the format you want to display in the SAS output. ========================================================*/ /***************************************************** 5.1. Label - it describes each input variable This information will be kept in the resulting SAS data set. Most importantly, this information will be carried over to the SAS data sets derived from the initial data set. ******************************************************/ DM &#39;CLEAR LOG&#39;; DM &#39;CLEAR OUTPUT&#39;; DATA kids_label; INPUT @1 firstnam $11. @12 lastname $11. @23 birthday $10. @33 gender $1. @34 wklyrate 3.; LABEL firstnam=&#39;First name&#39; lastname=&#39;Last name&#39; birthday=&#39;Birthday in days from Jan. 1, 1960&#39; gender=&#39;Gender&#39; wklyrate=&#39;Rate&#39;; DATALINES; Douglas Lindgren 08/29/1996M115 Elizabeth Wilkerson 01/13/1997F95 Evangeline Chambers 03/11/1997F100 Arthur Hollander 07/19/1996M. ChristopherKalbfleisch04/13/1995M115 Stacy Siegel 11/15/1996F100 ; RUN; PROC PRINT DATA =kids_label; TITLE &#39;Daycare roster: kids Label&#39;; RUN; /******************************************************************* 5.2. SAS Date Informat/Format About SAS Dates: 1. A SAS date is saved as a numeric value that represents the number of days since January 1, 1960. A negative value implies that the date is earlier than January 1, 1960. A positive value means the date is after January 1, 1960. 2.FORMAT: If you want to display a date, you need to specify a format. Otherwise, you will have a numerical value. There are many different formats for dates in SAS. See the following link to the SAS document: https://documentation.sas.com/?docsetId=lrcon&amp;docsetTarget=p1wj0wt2ebe2a0n1lv4lem9hdc0v.htm&amp;docsetVersion=9.4&amp;locale=en 3. INFORMAT: Different date variables in source data may have different formats (even in a single data file), when we use INPUT or INFILE to read data in SAS, we have to tell SAS the format of the corresponding date variable. Since the format is the for the incoming date variable, is called INFORMAT. ******************************************************************************/ DM &#39;CLEAR LOG&#39;; DM &#39;CLEAR OUTPUT&#39;; DATA kids_format; INPUT @1 firstnam $11. @12 lastname $11. @23 birthday mmddyy10. /* The form of date has format: mmddyy10. Because it is used in the input statement, It is called INFORMAT. */ @33 gender $1. @34 wklyrate 3.; LABEL firstnam=&#39;First name&#39; lastname=&#39;Last name&#39; birthday=&#39;Birthday in days from Jan. 1, 1960&#39; gender=&#39;Gender&#39; wklyrate=&#39;Rate&#39;; DATALINES; Douglas Lindgren 08/29/1996M115 Elizabeth Wilkerson 01/13/1997F95 Evangeline Chambers 03/11/1997F100 Arthur Hollander 07/19/1996M. ChristopherKalbfleisch04/13/1995M115 Stacy Siegel 11/15/1996F100 ; RUN; PROC PRINT DATA =kids_format; FORMAT birthday worddate18. wklyrate dollar7.1; TITLE &#39;Daycare roster&#39;; RUN; /* ====================================================== 6. User-Defined FORMATS - More to come next week =========================================================*/ DM &#39;CLEAR LOG&#39;; DM &#39;CLEAR OUTPUT&#39;; PROC FORMAT; VALUE $genderfmt &#39;F&#39;=&#39;Female&#39; &#39;M&#39;=&#39;Male&#39;; RUN; PROC PRINT DATA =Kids_format LABEL; FORMAT GENDER $genderfmt. birthday date9.; TITLE &#39;Daycare roster&#39;; RUN; "],["read-data-from-other-applications.html", "Chapter 5 Read Data from Other Applications 5.1 More INFILE Options 5.2 Reading in Existing SAS Data Sets 5.3 Reading Data via Wizard 5.4 Loading Data PROC IMPORT 5.5 Read Data with URL 5.6 Learning Coding by Examples", " Chapter 5 Read Data from Other Applications We introduced the very basic text format data with different structures (layouts) and loaded them to SAS. In practice, we frequently work with data sets coming from different data sources with different data formats such CSV, xls, etc. Sometimes, the data set may be stored in a remote server or a premise or cloud database. We need to have a certain way to load the available data to SAS for various analyses. Recall that informat is used to tell SAS how to read a variable whereas format is used to tell SAS how to display or write values of a variable. Informats is basically used when you read or import data from either an external file (Text/Excel/CSV) or read in sample data which was created using CARDS/DATALINES statement. It is also used when you create a new variable in a data set. Format can be used in both Data Steps and PROC Steps whereas Informat can be used only in Data Steps. Before introducing the other methods for loading different data sources, we briefly discuss how to handle missing values in loading data to SAS. 5.1 More INFILE Options We have introduced INFILE options FIRSTOBS = and OBS= to read data with descriptions and comments. The next few INFILE options are useful to handle missing values when loading data to SAS. 5.1.1 DLM DLM is to treat consecutive commas as a single comma, DSD will assign missing values between consecutive commas. Figure 5.1: INFILE option: DLM. Note that in the above output, only 2 observations because of the default FLOWOVER functionality (i.e., by default, the input pointer moves to the next record to fulfill the number of variables used in the input statement if some of the variables are missing in the first line.). Also, the final ‘3’ is ignored because there is no variable to store it. 5.1.2 DSD DSD treats two consecutive delimiters as missing values and removes quotation marks from character values. Because of this, the following data step will read the data correctly. Figure 5.2: INFILE option: DSD. 5.1.3 MISSOVER MISSOVER option prevents the default behavior mentioned above prevents the input pointer from moving to the next line and assigns missing values to the remaining variables. This means that if the missing values happen to be at the end of every record, the data will be read incorrectly. Figure 5.3: INFILE option: MISSOVER. 5.2 Reading in Existing SAS Data Sets It is quite often to have SAS format data files. To load SAS format data files to SAS, we only need to use SETstatement. The syntax is given below This means we need to define a permanent library referring to the folder in which the SAS data files are stored. Note that INPUT and INFILE statements will not work since INPUT reads raw data from an external file (with INFILE statement) or from in-stream data lines (with DATALINES) in order to create SAS variables and observations. If two data sets with same variable names, we can use SET statements to stack the data sets. This will be discussed in detail later in data manipulation. 5.3 Reading Data via Wizard SAS has a data import wizard that allows users to import data from different applications. To use the import wizard in base SAS 9.4 (Windows), Files -&gt; Import wizard, users can find the list of data sources that be imported to SAS without writing SAS code. Then follow the self-directed steps to load data to SAS. The converted SAS data will be stored in the temporary library. The GUI of SAS studio is slightly different but has almost the same data formats. 5.4 Loading Data PROC IMPORT The point-n-click approach with import wizard can load one or a few data sets. In practice, we have hundreds of data sets to load to SAS for certain projects, in this case, manual loading with Wizard will be feasible. We need to load many data sets programmatically. This is particularly important in any analytic task that involves automation that prevents human intervention from the analysis process. PROC IMPORT will do the trick. A good feature of importing Wizard in SAS is that it generates SAS code to perform the task that the Wizard performed. To explain, we assume a delimiter data file is stored in a physical location (my SAS Studio via OnDemand): Region&amp;State&amp;Month&amp;Expenses&amp;Revenue Southern&amp;GA&amp;JAN2001&amp;2000&amp;8000 Southern&amp;GA&amp;FEB2001&amp;1200&amp;6000 Southern&amp;FL&amp;FEB2001&amp;8500&amp;11000 Northern&amp;NY&amp;FEB2001&amp;3000&amp;4000 Northern&amp;NY&amp;MAR2001&amp;6000&amp;5000 Southern&amp;FL&amp;MAR2001&amp;9800&amp;13500 Northern&amp;MA&amp;MAR2001&amp;1500&amp;1000 ; The procedure PROC IMPORT reads the above data file with the following code SAS log will duplicate the above code and convert the PROC IMPORT to the standard DATA step code. The following output SAS data shows that the data loaded correctly. 5.5 Read Data with URL SAS can also read data from a remote computer via the internet or connect SAS to a database. The following is an example of reading a data file from the GitHub Data repository using PROC IMPORT. 5.6 Learning Coding by Examples This section uses several examples to explain different ways of loading different formats of data files to SAS. For convenience, the working data files used in the examples were uploaded to my GitHub repository. https://raw.githubusercontent.com/pengdsci/STA311/main/w04-iris-csv.csv, https://raw.githubusercontent.com/pengdsci/STA311/main/w04-iris-text.txt, https://github.com/pengdsci/STA311/raw/main/w04-iris-xls.xls https://github.com/pengdsci/STA311/raw/main/w04-iris-xlsx.xlsx /******************************************************************** Topics: 1. Handling challenging source data (text data via INPUT or INFILE-INPUT Statements) 2. Read DELIMITERED data files 3. Read data using INPUT WIZARD 4. Data formats: Excel, CSV and Text 5. Loading the SAS dataset to SAS 6. EXPORT SAS data to CSV ********************************************************************/ DM &#39;CLEAR LOG&#39;; DM &#39;CLEAR OUT&#39;; OPTIONS PS=90 LS=70 NOCENTER NONUMBER NODATE; /** library on the RAMCLOUD - synchronizing files between my computer and my OneDrive on the RamCloud **/ LIBNAME w04 &quot;C:\\STA311\\w04&quot;; /*NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN Topic 1: Reading challenging data: external and in-line Challenges: missing values, character variables string value contains blanks, special formatted numerical values, etc. NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN*/ /* Missing values at the end of the record: MISSOVER!! INFILE statement&#39;s MISSOVER option to read records when some of the values are missing at the end of a record */ DATA reading; /* temporary SAS data */ INFILE DATALINES MISSOVER; /* INFILE-DATALINES read in-line data */ INPUT Name $ Week1-Week5; /* shortcut of patterned variable names */ /* Caution: Records 3 and 4 have trailing missing values. */ DATALINES; Robin 3 2 5 1 6 Jack 4 4 4 3 4 Tim 3 0 0 Martin 1 0 1 1 Caroline 2 3 4 5 6 ; RUN; PROC PRINT DATA = reading; TITLE &#39;Summer Reading Program&#39;; VAR Name Week1-Week5; /* Caution: In proc print, the variable type should NOT be specified. Otherwise, an error will be written to the log */ RUN; /* Missing values in the middle or at the end of the record: DSD!! INFILE statement&#39;s DSD option to read records when some of the values are missing in the middle or at the beginning of a record */ /* delimiter sensitive data - DSD */ DATA survey; LENGTH Name $ 9; /* Katherine has 9 characters! */ INFILE DATALINES DLM=&#39;,&#39; DSD; /* 1. in-line data is comma delimited 2. Missing values occurred in the middle of the records */ INPUT Name $ (Q1-Q5) ($); /* Pay attention to the character variables with patterned names! */ DATALINES; Robert,,A,C,A,D William,B,C,A,D,A Linda,C,B,,A,C Lisa,D,D,D,C,A Katherine,A,B,C,D,A RUN; PROC PRINT DATA = survey; TITLE &#39;Survey Results&#39;; VAR Name Q1-Q5; /* Requested character variables without the specification of var type! */ RUN; /* The following program illustrates that the DSD option can also be used i) When there is a missing value at the beginning of a record, and ii) When the data are delimited by blanks (in conjunction with the DLM= option): */ DATA survey; LENGTH Name $ 9; infile DATALINES DLM=&#39; &#39; DSD; input Name $ (Q1-Q5) ($); DATALINES; Robert A C A D William B C A D A Linda C B A C D D D C A Katherine A B C D A RUN; PROC PRINT data = survey; title &#39;Survey Results&#39;; var Name Q1-Q5; RUN; /** Modifiers (&amp;) and (:) - modifier list input for some challenges in text data files: 1. The ampersand (&amp;) modifier allows you to read character values that contain embedded blanks. CAUTION: The ampersand (&amp;) that follows the city variable in the INPUT The statement tells SAS that the city values may contain one or more SINGLE embedded blanks. Because the ampersand modifier is used, SAS will read the city value UNTIL TWO OR MORE CONSECUTIVE blanks are encountered. That is a very important point!!!! When you use ampersand modified list input, the values that you are reading in must be separated by two or more consecutive blanks. You cannot use any other delimiter to indicate the end of each field. 2. The colon (:) modifier allows you to read nonstandard data values and character values that are longer than eight characters, but which have no embedded blanks. **/ DATA citypops; INFILE DATALINES FIRSTOBS = 2; INPUT city pop2000; /* This will not be correct! (1) city is a character variable. (2) Some of its value involves embedded blank. (3) Variable length is also an issue */ DATALINES; City Yr2000Popn New York 8008278 Los Angeles 3694820 Chicago 2896016 Houston 1953631 Philadelphia 1517550 Phoenix 1321045 San Antonio 1144646 San Diego 1223400 Dallas 1188580 San Jose 894943 ; RUN; PROC PRINT data = citypops; title &#39;The citypops data set&#39;; RUN; /** The issues in the above code were fixed in the following code **/ DATA citypops; INFILE DATALINES FIRSTOBS = 2; LENGTH city $ 12; INPUT city &amp; pop2000; DATALINES; City Yr2000Popn New York 8008278 Los Angeles 3694820 Chicago 2896016 Houston 1953631 Philadelphia 1517550 Phoenix 1321045 San Antonio 1144646 San Diego 1223400 Dallas 1188580 San Jose 894943 ; RUN; PROC PRINT data = citypops; TITLE &#39;The citypops data set: with &amp;&#39;; format pop2000 comma10.; RUN; /****************************************************************************** The colon (:) modifier allows us to use list input to read nonstandard data values and character values that are longer than eight characters, but which contain no embedded blanks. The colon (:) indicates that values are read until a blank (or other delimiters) is encountered, and then an informat is applied. If an informat for reading character values is specified, the w value specifies the variable&#39;s length, overriding the default length of 8. *******************************************************************************/ DATA citypops_colon; INFILE DATALINES FIRSTOBS = 2; INPUT city &amp; $12. pop2000 : comma.; /* &amp; --&gt; will take care of one or more SINGLE blanks in the first character variable. $12. --&gt; takes care of variable type and LENGTH, caution: (.) is required! : --&gt; tells SAS to read until a blank (or other delimiter) is encountered, and then an informat is applied. Here, comma. is the informat. Caution: Since in this example, the INFORMAT is comma, so the delimiter should not be a comma! */ DATALINES; City Yr2000Popn New York 8,008,278 Los A ngeles 3,694,820 Chicago 2,896,016 Houston 1,953,631 Philadelphia 1,517,550 Phoenix 1,321,045 San Antonio 1,144,646 San Diego 1,223,400 Dallas 1,188,580 San Jose 894,943 ; RUN; PROC PRINT DATA = citypops_colon; TITLE &#39;The citypops data set: Both (&amp;) and (:)&#39;; FORMAT pop2000 comma10.; RUN; DATA citypops_no_colon; INFILE DATALINES FIRSTOBS = 2; INPUT city &amp; $12. pop2000 ; /* &amp; --&gt; will take care of one or more SINGLE blanks in the first character variable. $12. --&gt; takes care of variable type and LENGTH, caution: (.) is required! : --&gt; tells SAS to read until a blank (or other delimiter) is encountered, and then an informat is applied. Here, comma. is the informat. Caution: Since in this example, the INFORMAT is comma, so the delimiter should not be a comma! */ DATALINES; City Yr2000Popn New York 8,008,278 Los A ngeles 3,694,820 Chicago 2,896,016 Houston 1,953,631 Philadelphia 1,517,550 Phoenix 1,321,045 San Antonio 1,144,646 San Diego 1,223,400 Dallas 1,188,580 San Jose 894,943 ; RUN; PROC PRINT DATA = citypops_no_colon; TITLE &#39;The citypops data set: Both (&amp;) and (:)&#39;; FORMAT pop2000 comma10.; RUN; /*NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN Topic 3: Read external data with common formats: Excel, CSV, Text, and data from other applications such as SPSS using PROC IMPORT NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN*/ PROC IMPORT OUT= WORK.Iris_TEMPLATE02 /* SAS file in the temporary library */ DATAFILE= &quot;C:\\STA311\\w04\\w04-iris-xlsx.xlsx&quot; /* source xlsx file */ DBMS=EXCEL REPLACE; /*File type, replace if already exists*/ RANGE=&quot;&#39;w04-iris$&#39;&quot;; /*Indicates the name of the sheet within the Excel workbook Note that sheet names can only be 31 characters long. */ GETNAMES=YES; /*Indicates the first row contains variable names. The default setting and SAS will automatically use the first row of data as variable names. If the first row of your sheet does not contain variable names use the getnames=no.*/ MIXED=YES; /*Indicates both numeric and character variables in the data set. SAS uses the first eight rows of data to determine whether the variable should be read as character or numeric. The default setting mixed=no assumes that each variable is either all characters or all numeric. If you have a variable with both character and numeric values or a variable with missing values use mixed=yes statement to be sure SAS will read it correctly. */ SCANTEXT=YES; /*Tells SAS to scan columns to determine the length of the text values*/ USEDATE=YES; /*Tells SAS to assign a DATE format to date data*/ SCANTIME=YES; /* Tells SAS to assign a TIME format to time data */ RUN; PROC PRINT; RUN; PROC CONTENTS DATA = Iris_TEMPLATE02; RUN; /** Make sure SAS can find the CSV data file **/ PROC IMPORT DATAFILE = &quot;C:\\STA311\\w04\\w04-iris-csv.csv&quot; OUT = IRISCSV /* name of the SAS data set to send to the temporary library */ DBMS = CSV /* Database management system: CSV */ GETNAMES = YES; /* The first row is not a record. */ ; RUN; PROC IMPORT DATAFILE = &quot;C:\\STA311\\w04\\w04-iris-text.txt&quot; OUT = TEXTIRIS /* */ DBMS = CSV REPLACE; GETNAMES = YES; RUN; PROC IMPORT OUT= WORK.demographics DATAFILE= &quot;C:\\STA311\\w04\\w04-Demographics.sav&quot; DBMS=SPSS REPLACE; RUN; /*NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN Topic 4: Export SAS data set to a CSV format data Why CSV? The CSV (short for &quot;comma-separated values&quot;) is one of the most flexible formats. CSV is a bit faster, smaller in size, and very easy to handle (even in Excel) and many existing applications understand it, it is a widely used standard. It is still the first choice in many situations. This is why I only use an example to demonstrate this programmatic approach to export CSV data! NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN*/ PROC EXPORT DATA= IRIS_template /* Export the SAS file from the permanent library and save it as a CSV file in the next folder. */ OUTFILE= &quot;C:\\STA311\\w04\\outcsv_mycsv.csv&quot; DBMS=CSV REPLACE; /* REPLACE will overwrite the existing csv file with the same name. */ PUTNAMES=YES; /* carry names of the variables in the SAS data file */ RUN; /** Why do we need PROC IMPORT/EXPORT while we have INPUT WIZARD? **/ /*NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN Topic 5: Loading SAS Data set to SAS for DATA MANAGEMENT We only focus on the syntax and some basic controls this time. We will use this SET statement frequently beyond this point. Basic Syntax: DATA newdata; SET oldSASdataset; more statements to modify the oldSASdataset; RUN; NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN*/ /**** A simple example: Citypops.sas7bdat is in the temporary library ***/ PROC PRINT DATA = Citypops; TITLE &quot;Old City Population Data Set&quot;; RUN; DATA NewCityPops; SET CityPops; New_popn = ROUND(pop2000 * 1.0001, 1); /* add a new variable reflecting the new population size. */ RUN; /** ROUND() is an SAS built-in function: The following examples illustrate how to use it: round(1234.56789, 100)-----&gt; 1200; round(1234.56789, 10) -----&gt; 1230; round(1234.56789, 1) -----&gt; 1235; round(1234.56789, .1) -----&gt; 1234.6; round(1234.56789, .01)-----&gt; 1234.57; round(1234.56789, .001)----&gt; 1234.568; round(1234.56789, .0001)---&gt; 1234.5679; round(1234.56789, .00001)--&gt; 1234.56789; round(1234.56789, .1111)---&gt; 1234.5432; **/ PROC PRINT DATA = NewCityPops; TITLE &quot;New City Population Data&quot;; RUN; TITLE &quot; &quot;; /* clear the title for next output */ "],["descriptive-statistics.html", "Chapter 6 Descriptive Statistics 6.1 Frequency Table Analysis 6.2 Numerical Summary Statistics 6.3 Learning Coding by Examples", " Chapter 6 Descriptive Statistics Once we finish reading data to SAS, we can use SAS to perform basic descriptive analysis such as frequency tables, different charts for numerical measures, etc. For convenience, we use the following data set for all illustrative examples in this chapter. This is data about penguins collected by Dr. Kristen Gorman and the Palmer Station in Antarctica. There are 344 cases and 7 columns. With both numerical and categorical variables, there are options for exploring, including looking for differentiators between the three species of penguin. https://raw.githubusercontent.com/pengdsci/sta553/main/w02-penguins.csv FILENAME pguin URL &quot;https://raw.githubusercontent.com/pengdsci/sta553/main/w02-penguins.csv&quot;; PROC IMPORT DATAFILE = pguin OUT = penguin DBMS = CSV REPLACE; GETNAMES = YES; RUN; We first look at the types of variables in the working data set using PROC CONTENTS. TITLE &quot;Information of Penguin Data&quot;; PROC CONTENTS DATA = penguin; RUN; The output contains three tables, the second table contains information about the SAS engine. We only look at the first and the third table that contains data information. We can see that there are 344 observations and 9 variables. All variables in the data set are in numerical form except for the year. We will use a SAS function to convert character variables to numerical variables in order to do appropriate analyses. 6.1 Frequency Table Analysis We can use PROC FREQ to produce frequency tables based on categorical variables. We can also group numerical variables to create categorical variables and then create frequency tables. Group variables in a data set are considered as data manipulation, We will discuss this in later chapters. The next examples will use the existing categorical variables in the data set. TITLE &quot;Frequency by species and locations&quot;; PROC FREQ DATA=penguin; TABLES species; /* species table */ TABLES island; /* location table */ RUN; The above two procedures give the frequency distributions of species and island in the same procedure. A SAS program consists of individual data and procedure steps. Each procedure allows only one title and a few sub-titles, all titles and sub-titles are always printed on the top of the output of the procedure. We can use two procedure steps to give specific titles for individual tables. We may want to know whether a particular species of penguin likes to live in a particular location. The two-way frequency table (cross-tabulation) gives this type of information. TITLE &quot;Two-way Frequency Table&quot;; PROC FREQ DATA=penguin; TABLES species * island; /* species table */ RUN; Note the asterisk (*) between the variables species and island on the tables statement. The above two-way table contains four different frequencies. Sometimes, we may be interested in only one type of frequency. We can select a particular frequency to print out by using the norow, nocol, and nofreq options on the tables statement to suppress the printing of the row percentages, column percentages, and frequencies (leaving just the cell percentages). Note that the options come after the forward-slash ( / ) on the tables statement. TITLE &quot;Two-way Relative Frequency Table&quot;; PROC FREQ DATA=penguin; TABLES species * island / NOROW NOCOL NOFREQ ; RUN; Note that the order of the options does not matter. 6.2 Numerical Summary Statistics In elementary statistics, we learned several numerical measures of numerical data (variable) SAS procedures PROC MEANS and PROC UNIVARIATE calculate these numerical summary measures and also create plots such as basic statistical graphics as by-products. Since some of the numerical variables stored in the data are in the character form, we first convert them back to numerical form in order to perform appropriate analysis. DATA new_penguin; /* define a new data set */ SET Penguin; /* copy the data original data*/ body_mass = input(body_mass_g, 8.); /* conversion */ flipper_length = input(flipper_length_mm, 8.); bill_depth = input(bill_depth_mm, 8.); bill_length = input(bill_length_mm, 8.); RUN; PROC CONTENTS DATA = new_penguin; /* check the conversion */ RUN; 6.2.1 PROC MEANS PROC MEANS calculates the summarized statistics such as means, quartiles, size, etc. The detailed list of options is given in the following table. In the following example, we selected several summary statistics to report in PROC MEANS. TITLE &quot;Summary Statistics by PROC MEANS&quot;; PROC MEANS DATA=new_penguin N MIN Q1 MEAN STD MEDIAN Q3 MAX; VAR body_mass; RUN; Suppose we would like to get the summary statistics separately for different species. We can use the class statement (shown below) to get separate results for the different values of species. TITLE &quot;Summary Statistics by SPECIES&quot;; PROC MEANS DATA=new_penguin N MIN Q1 MEAN STD MEDIAN Q3 MAX; CLASS species; VAR body_mass; RUN; We can also save the output of the summary table as a SAS data set. TITLE &quot;Summary Statistics by OUTPUT SAS dataset&quot;; PROC MEANS DATA=new_penguin N MIN Q1 MEAN STD MEDIAN Q3 MAX; CLASS species; VAR body_mass; OUTPUT OUT= SummaryPenguin /autoname; RUN; PROC PRINT; RUN; 6.2.2 PROC UNIVARIATE We first look at the univariate analysis using PROC UNIVARIATE. PROC UNIVARIATE DATA=new_penguin; VAR body_mass; RUN; The output tables of PROC UNIVARIATE are summarized in the following. 6.3 Learning Coding by Examples The following examples contain more detailed information on the three procedures: MEANS, FREQ, and UNIVARIATE. We still use the iris data set in different formats that can be found at https://raw.githubusercontent.com/pengdsci/STA311/main/w04-iris-csv.csv, https://raw.githubusercontent.com/pengdsci/STA311/main/w04-iris-text.txt, https://github.com/pengdsci/STA311/raw/main/w04-iris-xls.xls https://github.com/pengdsci/STA311/raw/main/w04-iris-xlsx.xlsx Some inferential information introduced in various examples is not required for this class. We keep this type of information in this note to make the ePack a useful reference book. /********************************************************** Author: Cheng Peng Date: 2/15/2021 Topics 1. Loading tab and csv file to SAS 2. PROC MEANS Basics 3. PROC MEANS - beyond averages 4. PROC FREQ Basics 5. PROC UNIVARIATE basics ***********************************************************/ DM &quot;CLEAR LOG&quot;; DM &quot;CLEAR OUT&quot;; LIBNAME w05 &quot;C:\\STA311\\w05&quot;; OPTIONS PS = 94 LS =74 NODATE NONUMBER NOCENTER; /******************************************************* Topic 1: Loading Data with Data and PROC step Read text and csv data into SAS with DATA STEP and PROC IMPORT - Pay attention to the DELIMITER When using INFILE-INPUT statement in a data step ********************************************************/ /** txt - tab-delimited data **/ DATA TXTIRIS; LENGTH variety $ 10; /* txt files are tab-delimited data. The delimiter of this data is &#39;09&#39;x that has to be specified in the following INFILE statement */ INFILE &quot;C:\\STA311\\w05\\w05-iris-text.txt&quot; delimiter = &#39;09&#39;x FIRSTOBS = 2; INPUT SepalLengt SepalWidth PetalLength PedalWidth variety $; RUN; PROC CONTENTS DATA = TXTIRIS; RUN; /** CSV - comma separated values, dlm =&quot;,&quot; should be specified in the INFILE statement. **/ DATA CSVIRIS; LENGTH variety $ 10; INFILE &quot;C:\\STA311\\w05\\w05-iris-csv.csv&quot; dlm=&quot;,&quot; FIRSTOBS = 2; INPUT SepalLength SepalWidth PetalLength PedalWidth variety $; RUN; PROC CONTENTS DATA = CSVIRIS; RUN; /** PROC IMPORT Methods **/ /** PROC IMPORT TXT **/ PROC IMPORT OUT= WORK.txt_iris DATAFILE= &quot;C:\\STA311\\w05\\w05-iris-text.txt&quot; DBMS=TAB REPLACE; /* .txt is a tab-delimited data */ GETNAMES=YES; DATAROW=2; /** data record starts from row 2, The first row lists variable names **/ GUESSINGROWS =150; /** This option is required since the length of variety is more than 8 bytes **/ RUN; /* PROC IMPORT - CSV */ PROC IMPORT OUT= WORK.iris_csv DATAFILE= &quot;C:\\STA311\\w05\\w05-iris-csv.csv&quot; DBMS=CSV REPLACE; /* database management system identifier: CSV */ GETNAMES=YES; DATAROW=2; /* */ GUESSINGROWS =MAX; /* Need to be specified whenever the data set has character variables. The maximum number of row SAS can guess is 32767. */ RUN; /**************************************************************** Topic 2. PROC MEANS Certain SAS procedures can only be performed on numeric data. Two such procedures - PROC MEANS and PROC UNIVARIATE - are illustrated here using the height/weight SAS data set. (Note that PROC SUMMARY generates output similar to PROC MEANS.) Several Statements to know: 1. CLASS 2. BY 3. OUTPUT ****************************************************************/ DM &quot;CLEAR LOG&quot;; DM &quot;CLEAR OUT&quot;; /** Example 2.1: default descriptive statistics - N Mean Std Dev Minimum Maximum **/ PROC MEANS DATA = iris_csv; /* Begin the PROC step */ /* Add 2 titles */ TITLE1 &#39;PROC MEANS: Example 2.1&#39;; TITLE2 &#39;No keywords specified&#39;; RUN; /* End the PROC step */ /** Explore the information in the data set **/ PROC CONTENTS DATA = IRIS_CSV; RUN; /****************************************************************** Example 2.2: available keywords - all descriptive statistics When using PROC MEANS, the CLASS statement avoids having to sort the data first, but the CLASS statement is more suited to smaller data sets or when just a few CLASS variables are to be used. Some of the keywords available with PROC MEANS: N - number of observations MEAN - mean value MIN - minimum value Q1 - first quartile Median - middle value of the sorted data set Q3 - third quartile MAX - maximum value SUM - the total values NMISS - number of missing values MAXDEC = n - setting the maximum number of decimal places *******************************************************************/ PROC MEANS DATA = IRIS_CSV N MIN Q1 MEDIAN MEAN Q3 MAX SUM NMISS ; VAR sepal_length; /*Separate the analysis by values of variety */ CLASS variety; /* CLASS statement produces a single table */ /* Add 3 titles */ TITLE1 &#39;PROC MEANS: Example 2.2&#39;; TITLE2 &#39;Use of VAR, CLASS, and TITLE statements&#39;; TITLE3 &#39;CLASSED by variety&#39;; RUN; /* Example 2.3: BY- statement to replace CLASS statement! BY statement will be used frequently in the future. In order to use the BY statement, the data set has to be sorted by the CLASS variable - variety! */ PROC SORT DATA = IRIS_CSV; BY variety; RUN; OPTION LS=150; /* pay attention to the */ PROC MEANS N MIN Q1 MEAN MEDIAN Q3 MAX STD SUM NMISS MAXDEC = 1 DATA = iris_csv MAXDEC = 3; /*Separate the analysis by values of variety */ BY variety; /* BY statement produces three separate tables! */ /*Apply analysis only to &quot;sepal_length&quot; variable*/ VAR sepal_length; /* Add 3 titles */ TITLE1 &#39;PROC MEANS: Example 2.3&#39;; TITLE2 &#39;Use of VAR, BY, and TITLE statements&#39;; TITLE3 &#39;CLASSED by variety&#39;; TITLE4 &quot;BY Statement - Produces 3 Tables&quot;; RUN; /** Other descriptive statistics with PROC MEANS: SUM Sum of observations MEDIAN 50th percentile P1 -&gt; 1st percentile P5 -&gt; 5th percentile P10 -&gt; 10th percentile P90 -&gt; 90th percentile P95 -&gt; 95th percentile P99 -&gt; 99th percentile Q1 -&gt; First Quartile Q3 -&gt; Third Quartile ***** VAR -&gt; Variance RANGE -&gt; Range USS -&gt; Uncorr. sum of squares CSS -&gt; Corr. sum of squares STDERR -&gt; Standard Error T -&gt; Student抯 t value for testing Ho: md = 0 PRT -&gt; P-value associated with t-test above SUMWGT -&gt; Sum of the WEIGHT variable values QRANGE -&gt; Quartile range ***** CLM -&gt; confidence limits on the mean LCLM -&gt; lower confidence limit on the mean (one-sided) UCLM -&gt; upper confidence limit on the mean (one-sided) **/ /** Example 2.4: confidence interval for mean sepal_length and sepal_width by variety **/ PROC MEANS DATA = IRIS_CSV MAXDEC = 3 N /* sample size */ MEAN /* sample mean */ MAXDEC = 1 /* decimal places to keep */ ALPHA = 0.01 /* significant level */ CLM /* two-sided confidence limits: 99% */ LCLM /* lower confidence limit: 99% */ UCLM /* upper confidence limit: 99% */ ; /*Separate the analysis by values of variety */ CLASS variety; /* want to create a single table */ /*Apply analysis only to &quot;sepal_length&quot; and &quot;sepal_width&quot; variables*/ VAR sepal_length sepal_length; /* Add 3 titles */ TITLE1 &#39;PROC MEANS: Example 2.4&#39;; TITLE2 &#39;Confidence Intervals: 99%&#39;; TITLE3 &#39;CLASSED by variety&#39;; RUN; PROC PRINT; RUN; OPTIONS PS = 90 LS =70 NONUMBER NODATE; /* global options */ /* Example 2.5: OUTPUT- statement creates an SAS data set that stores the output information from PROC MEANS! - This is another method for creating SAS data sets. */ PROC MEANS DATA = IRIS_CSV ALPHA=0.01 NOPRINT; /* Setting up confidence level. If not specified, default level 0.05 */ *CLM /* suppress the output statistics */ N /* sample size */ MEAN /* sample mean */ MAXDEC = 1 /* decimal places to keep */ ALPHA = 0.01 /* significant level */ CLM /* two-sided confidence limits: 99% */ LCLM /* lower confidence limit: 99% */ UCLM /* upper confidence limit: 99% */ ; /*Separate the analysis by values of variety */ CLASS variety; /* want to create a single table */ /*Apply analysis only to &quot;sepal_length&quot; and &quot;sepal_width&quot; variables*/ VAR sepal_length sepal_length; /* output a SAS data set */ OUTPUT OUT = My_CLM /* output SAS data set --&gt; temp lib*/ N = size /* sample size */ MEAN = avg STDERR = sd_err /* standard error */ LCLM = LCI /* lower confidence limit */ UCLM = UCI; /* upper confidence limit */ /* Add 3 titles */ TITLE1 &#39;PROC MEANS: Example 2.5&#39;; TITLE2 &#39;Confidence Intervals: 99%&#39;; TITLE3 &#39;CLASSED by variety&#39;; RUN; TITLE &quot;&quot;; /* this clears all previous titles */ PROC PRINT; RUN; /************************************************************** Topic 3: PROC FREQ Frequency tables and crosstabulation tables provide a way to summarize data for ordinal and categorical variables. Frequency tables show the distribution of a variable&#39;s values. **************************************************************/ /** Example 3.1. Simple frequency table **/ PROC FREQ DATA = IRIS_CSV; TABLE VARIETY; TITLE &quot;Frequency Table of Variety&quot;; RUN; /** Example 3.2. Output frequency table to a SAS data set Frequencies and percentages calculated using Proc Freq can also be saved to an output dataset using the OUT option combined with the TABLES statement. The OUTCUM option can also be added to include the cumulative frequencies in the output dataset **/ PROC FREQ DATA = IRIS_CSV; TABLE VARIETY / OUT = Variety_FREQ OUTCUM; TITLE1 &quot;Frequency Table of Variety&quot;; TITLE2 &quot;Store the output to a SAS data set&quot;; RUN; PROC PRINT; TITLE &quot;Print out the output Frequency table&quot;; RUN; TITLE &quot;&quot;; /** We will revisit PROC FREQ after we do some data manipulation **/ /************************************************************** Topic 4: PROC UNIVARIATE PROC UNIVARIATE produces descriptive statistics on continuous variables just like proc means, but many more of them, and also can produce some univariate plots. **************************************************************/ OPTION NOCENTER LS = 90; /* Example 4.1: Univariate analysis of a numerical variable -- a simple example */ PROC UNIVARIATE DATA = IRIS_CSV NORMAL /* normality test */ FREQ /* frequency table of sepal_length: not useful*/ PLOT; /* plot of the histogram of sepal_length */ VAR Sepal_length; /* specification of details in the histogram 1. Place a normal curve on the top of the histogram */ HISTOGRAM Sepal_length/NORMAL; TITLE &#39;PROC UNIVARIATE EXAMPLE&#39;; FOOTNOTE &#39;Evaluate the distribution of Sepal_length&#39;; RUN; TITLE &quot;&quot;; FOOTNOTE &quot;&quot;; /* Example 4.2: PROC UNIVARIATE -- OUTPUT SAS Data set This is a very simple example with a few descriptive statistics */ PROC UNIVARIATE DATA = IRIS_CSV NOPRINT; VAR Sepal_length; OUTPUT OUT = UNIVAR_OUT_AVG /* output data set #1 */ MEAN = Sepal_length_avg; OUTPUT OUT = UNIV_OUT_MORE /* output data set #2 */ /* Three descriptive statistics were written to the SAS data set */ MEAN =Sepal_L_AVG STD = Sepal_L_STD MIN = Sepal_L_MIN; RUN; /****************************************************** Available Statistics for OUT in PROC UNIVARIATE *** Descriptive Statistics *** CSS ==&gt; Sum of squares corrected for the mean CV ==&gt; Percent coefficient of variation KURTOSIS | KURT ==&gt; Measurement of the heaviness of tails MAX ==&gt; Largest (maximum) value MEAN ==&gt; Arithmetic mean MIN ==&gt; Smallest (minimum) value MODE ==&gt; Most frequent value (if not unique, the smallest mode) N==&gt; Number of observations on which calculations are based NMISS==&gt; Number of missing observations NOBS==&gt; Total number of observations RANGE==&gt; Difference between the maximum and minimum values SKEWNESS | SKEW==&gt; Measurement of the tendency of the deviations to be larger in one direction than in the other STD | STDDEV==&gt; Standard deviation STDMEAN | STDERR==&gt; Standard error of the mean SUM==&gt; Sum SUMWGT==&gt; Sum of the weights USS==&gt; Uncorrected sum of squares VAR==&gt; Variance **** Quantile Statistics **** MEDIAN | Q2 | P50==&gt; middle value (50th percentile) P1==&gt; 1st percentile P5==&gt; 5th percentile P10==&gt; 10th percentile P90==&gt; 90th percentile P95==&gt; 95th percentile P99==&gt; 99th percentile Q1 | P25==&gt; Lower quartile (25th percentile) Q3 | P75==&gt; Upper quartile (75th percentile) QRANGE==&gt; Difference between the upper and lower quartiles (also known as the inner quartile range) *** Robust Statistics *** GINI==&gt; Gini抯 mean difference MAD==&gt; Median absolute difference QN==&gt; 2nd variation of median absolute difference SN==&gt; 1st variation of median absolute difference STD_GINI==&gt; Standard deviation for Gini抯 mean difference STD_MAD==&gt; Standard deviation for median absolute difference STD_QN==&gt; Standard deviation for the second variation of The median absolute difference STD_QRANGE==&gt; Estimate of the standard deviation, based on interquartile range STD_SN==&gt; Standard deviation for the first variation of the median absolute difference *** Hypothesis Test Statistics *** MSIGN==&gt; Sign statistic NORMAL==&gt; Test statistic for normality. If the sample size is less than or equal to 2000, this is the Shapiro-Wilk W statistic. Otherwise, it is the Kolmogorov D statistic. PROBM==&gt; Probability of a greater absolute value for the sign statistic PROBN==&gt; Probability that the data came from a normal distribution PROBS==&gt; Probability of a greater absolute value for the signed-rank statistic PROBT==&gt; Two-tailed p-value for Student抯 t statistic with degrees of freedom SIGNRANK==&gt; Signed rank statistic T==&gt; Student t statistic to test the null hypothesis that the The population mean is equal to mu_0 ****************************************************/ "],["basic-statistics-graphics.html", "Chapter 7 Basic Statistics Graphics 7.1 Boxplot 7.2 Bar Charts 7.3 Histogram 7.4 Scatter Plots 7.5 Pair-wise Scatter Plot 7.6 Learning Coding by Examples", " Chapter 7 Basic Statistics Graphics Making high-quality statistical graphics is not an easy task in early versions of SAS. Since SAS 9.2, `ODS graphics ’ was introduced and supported by several SAS products (see the following list). The current SAS license at WCU has a few SAS products and all of them support ODS graphics. The OnDemand SAS Studio (free) has a much longer list of SAS products than the current WCU’s SAS license. We will not systematically introduce SAS ODS (Output Delivery System) and ODS graphics, instead, we only demonstrate how to use SAS PROC SGPLOT, PROC SGSCATTER, PROC SGPANEL to create basic statistics graphics such as bar charts, scatter plots, line graphs, etc. Quite different from the traditional SAS graphics, graphs created with ODS graphics will be in the Results Window, not in the Graph Window. We can double‐click on the graphics icon to view the file, using a local Windows graphics viewer. Graphs will be automatically saved in .png (portable network graphics) format files that are * Raster graphics; * Compact format; * Usable in most Windows applications. For convenience, we still use the penguin data set as our working data set to make various statistics graphics. https://raw.githubusercontent.com/pengdsci/sta553/main/w02-penguins.csv FILENAME pguin URL &quot;https://raw.githubusercontent.com/pengdsci/sta553/main/w02-penguins.csv&quot;; PROC IMPORT DATAFILE = pguin OUT = penguin DBMS = CSV REPLACE; GETNAMES = YES; RUN; DATA new_penguin; /* define a new data set */ SET Penguin; /* copy the data original data*/ body_mass = input(body_mass_g, 8.); /* conversion */ flipper_length = input(flipper_length_mm, 8.); bill_depth = input(bill_depth_mm, 8.); bill_length = input(bill_length_mm, 8.); RUN; We will only include the minimum graphical features in all graphics. More complex SAS graphics will be discussed later if time permits. 7.1 Boxplot The box plot is a graphical representation of a five-number summary. It is used to get a rough idea of the distribution of the underlying continuous variable. 7.1.1 Basic Box Plot The next example draws a basic vertical box plot. TITLE &quot;Vertical Box-plot of Body Mass Index&quot;; PROC SGPLOT DATA = new_penguin; VBOX body_mass; RUN; 7.1.2 Boxplots for Categories If we want to compare the distributions of body mass index among three species of penguins, the following code will create three box plots for comparisons. TITLE &quot;Vertical Box-plot of Body Mass Index by species&quot;; PROC SGPLOT DATA = new_penguin; VBOX body_mass / category= species; RUN; 7.1.3 Panel Box Plot Further, we could also compare the distribution between species across island. The following panel box plots serve the purpose. TITLE &quot;Panel Box-plot of Body Mass Index by species across the islands&quot;; PROC SGPANEL DATA = new_penguin; PANELBY island / ROWS = 1 COLUMNS = 3; VBOX body_mass / category= species; RUN; 7.2 Bar Charts Bar charts are used to visually display the distribution of categorical variables. This section will illustrate several different bar charts for different purposes. There are three categorical variables in the penguin data set, we will use them in different examples. 7.2.1 Basic Bar Chart for One Variable We first make a bar cart for species. TITLE &quot;Vertical Baar Chart of Species&quot;; PROC SGPLOT DATA = new_penguin; VBAR species; RUN; 7.2.2 Stacked Bar Charts A stacked bar chart can be used to compare the distributions of two categorical variables. TITLE &quot;Stacked Bar Chart of Species&quot;; PROC SGPLOT DATA = new_penguin; VBAR species/GROUP= sex; RUN; 7.2.3 Bar Charts with Means and Error Bars In some fields such as health and biological sciences, it is common to visualize means and standard deviations (standard errors) of different groups for comparison. The bar chart of means and errors is the right choice. TITLE &quot;Means and Standard Errors by Species&quot;; PROC SGPLOT DATA = new_penguin; VBAR species/RESPONSE = body_mass LIMITSTAT = stddev LIMITS = upper STAT = mean; RUN; 7.2.4 Panel Bar Charts Panel bar charts are used to compare means (of a numerical variable) across two categorical variables. TITLE &quot;Panel bar chart&quot;; PROC SGPANEL DATA = new_penguin; PANELBY sex/ ROWS = 1 COLUMNS = 3; VBAR species/RESPONSE = body_mass LIMITSTAT = stddev LIMITS = upper STAT = mean; RUN; 7.3 Histogram A histogram is used to display the distribution of numerical variables. For comparison, it is quite often to overlay two (but rarely more than three) histograms of different numerical variables. In many cases, we also add a density curve on the histogram for comparison (between the estimated density or the reference density function). 7.3.1 Histogram with Density Curves PROC SGPLOT DATA = new_penguin; HISTOGRAM body_mass; density body_mass; density body_mass / type = kernel; keylegend / location=inside position=topright; RUN; 7.3.2 Overlaid Histograms Overlaid histograms are used to compare the distributions of two numerical variables. TITLE &quot;Overlaid histogram&quot;; PROC SGPLOT DATA = new_penguin; HISTOGRAM bill_depth; HISTOGRAM bill_length / TRANSPARENCY = 0.5; RUN; 7.3.3 Panel Histogram TITLE &quot;Histogram with a kernel density curve&quot;; PROC SGPANEL DATA = new_penguin NOAUTOLEGEND; PANELBY sex / ROWS = 1 COLUMNS = 3; HISTOGRAM body_mass; DENSITY body_mass; DENSITY body_mass / TYPE = kernel; /* kernel density estimator */ KEYLEGEND / POSITION = BOTTOM; RUN; 7.4 Scatter Plots A scatter plot of two numerical variables shows the relationship between them. It is quite often that the relationship between numerical variables varies in categories of one or categorical variables. This section displays this kind of relationship between numerical variables under different conditions. 7.4.1 Basic Scatter Plot for Two Numeric Variables TITLE &quot;Scatter plot of Bill_depth and Bill_length by species&quot;; PROC SGPLOT DATA = new_penguin; SCATTER x = bill_depth y = bill_length / GROUP = species; RUN; The above scatter used color to represent different species. 7.4.2 Scatter Plot With Least Squares Regression Line If we simply look at the scatter plot for the over-association between bill_depth and bill_length, the pattern is not quite obvious. We may want to add a least regression line to the scatter plot to make it clearer. TITLE &quot;Scatter plot of Bill_depth and Bill_length by species&quot;; TITLE2 &quot;with lease square regression line&quot;; PROC SGPLOT DATA = new_penguin; SCATTER x = bill_depth y = bill_length / GROUP = species; REG x = bill_depth y = bill_length / cli clm nomarkers; RUN; We can see an overall negative correlation between bill_depth and bill_length. If we look at the same relationship within individual species, the scatter plot shows a positive correlation. We may want to add regression lines to individual species as well to the scatter plot. TITLE &quot;Correlation between Bill_depth and Bill_length by species&quot;; TITLE2 &quot;with lease square regression lines&quot;; PROC SGPLOT DATA = new_penguin; SCATTER x = bill_depth y = bill_length; REG x = bill_depth y = bill_length / GROUP = species clm; RUN; Surprisingly, bill_depth and bill_length within each species are all positively correlated which is opposite to what we observed from the overall scatter plot. This pattern is called Simpson’s paradox in statistics. 7.4.3 Panel Scatter Plot The notion of panel scatter plots is the same. We want to visualize the potential correlation between two numerical variables across the categories of a categorical variable. We have made a single scatter plot and colored different species with different colors. We can also make panel scatter plots such that the scatter plots of individual species are placed in distinct panels. TITLE &quot;Panel Scatter Plots: Bill_depth and Bill_length by Species&quot;; TITLE2 &quot;with LOESS smooth curves&quot;; PROC SGPANEL DATA = new_penguin; PANELBY species/ROWS = 1 COLUMNS = 3; SCATTER x = bill_depth y = bill_length/ GROUP = species; LOESS x = bill_depth y = bill_length; RUN; 7.5 Pair-wise Scatter Plot It is useful to visually inspect the potential high correlation between numerical variables (usually three or more) in regression modeling to see the potential impact of (pair-wise) collinearity (not the multicollinearity). For illustration, we use the 4 numerical variables in the new_penguin data set to make a pair-wise scatter plot. TITLE &quot;Pair-wise Scatter Plot&quot;; TITLE2 &quot;Penguins on Biscoe Island&quot;; PROC SGSCATTER DATA = new_penguin; WHERE island = &#39;Biscoe&#39;; MATRIX bill_depth bill_length flipper_length body_mass / GROUP = species DIAGONAL=(HISTOGRAM KERNEL); RUN; 7.6 Learning Coding by Examples This section provides more examples that use more SAS graphical statements to improve the previously introduced statistics graph aesthetically. For convenience, we use the SAS built-in data set in the following examples. /*************************************************** High-Quality Statistical Plots - SGPLOT Topics: 1 - Histograms 2 - Barcharts 3 - Scatter Plots 4 - Box-plots 5 - Simple Linear Regression Lines 6 - Density Curves ***************************************************/ DM &quot;CLEAR OUT&quot;; DM &quot;CLEAR LOG&quot;; /*** Permanent library ***/ LIBNAME sgplot &quot;C:\\STA311\\w06&quot;; /* permanent library for saving SAS data related to PROC SGPLOT */ /** Global options for outputs **/ OPTIONS PS = 76 LS = 76 NONUMBER NODATE; /**************************************** Review: Loading SAS data set to SAS *****************************************/ /** Have to use library reference to access any SAS data sets and load them to SAS */ DATA sgplot.myAirDataSet; SET sashelp.Air; /* This is a SAS built-in data set*/ RUN; DATA work.myWorkAirData; SET sgplot.myAirDataSet; RUN; /*********************************** *** Explore car.sas7bdat ************************************/ TITLE &quot;SAS Built-in Data Set: cars.sas7bdat&quot;; /* global option. Keep in mind that this title should be updated appropriately according to the new output*/ PROC CONTENTS DATA = sashelp.cars; /* sashelp is the library reference to the SAS built-in permanent library */ RUN; /* IMPORTANT: If you want to load a SAS data set to SAS from a folder, you should always create an SAS permanent library pointing to the folder, then use the library reference and SAS data or procedure steps to access the SAS format data. */ /************************ ** Topic 1: Histogram *************************/ * Example 1.0 - basic histogram; PROC SGPLOT DATA = Sashelp.cars; HISTOGRAM MSRP; /* The default histogram is based on the relative frequency table */ TITLE &quot;The Simplest Histogram of MSRP&quot;; RUN; /********************************************************************* Example 1.1. Histogram with more controls by specifying options. The syntax is: HISTOGRAM MSRP/&lt;options&gt; Available options can be found on the SAS web page **********************************************************************/ ODS GRAPHICS ON / WIDTH = 4.5IN HEIGHT = 3.5IN; /* control the size of the SAS graphic */ PROC SGPLOT DATA = Sashelp.cars; HISTOGRAM MSRP/ NBINS = 6 /* 6 vertical bars are requested. */ SCALE = count /* Default scale is percent */ Y2AXIS /* draw two vertical axes */ DATASKIN = GLOSS; /* effects of vertical bars */ TITLE &quot;Histogram of MSRP with more controls&quot;; RUN; ODS GRAPHICS OFF; /* Example 1.3 - histogram with a density curve: i.e., stack one curve on the other; */ ODS GRAPHICS ON / WIDTH = 4.5IN HEIGHT = 3.5IN; /** control the size of the SAS graphic **/ PROC SGPLOT DATA = Sashelp.cars; HISTOGRAM MSRP; /* use the default number of vertical bars */ DENSITY MSRP; /* By default, a default density curve is normal: mu = sample mean, sd = sample std you can also choose KERNEL option --&gt; data driven density estimator. */ TITLE &quot;Histogram of MSRP with Density Curve&quot;; RUN; ODS GRAPHICS OFF; /************************ ** Topic 2: Bar Charts *************************/ * Example 2.1 Basic Bar Charts; ODS GRAPHICS ON / WIDTH = 4.5IN HEIGHT = 3.5IN; PROC SGPLOT DATA = Sashelp.cars; VBAR Type; /* name of character variable used in the bar chart */ TITLE &#39;Barchart of Type of Vehicles&#39;; RUN; ODS GRAPHICS OFF; /* Example 2.2 - bar chart by the origin ; */ ODS GRAPHICS ON / WIDTH = 4.5IN HEIGHT = 3.5IN; PROC SGPLOT DATA = Sashelp.cars; HBAR Type / GROUP = Origin; TITLE &#39;Barchart of Type by the origin&#39;; RUN; ODS GRAPHICS OFF; *Example 2.3 - Response option ; DATA temp_cars; SET Sashelp.cars; counter = 1; /* add a new constant variable to the SAS data */ RUN; /* We use the counter as a response variable */ ODS GRAPHICS ON / WIDTH = 4.5IN HEIGHT = 3.5IN; PROC SGPLOT DATA = temp_cars; VBAR Type / RESPONSE = counter; /* RESPOSE option adds up all values of the variable counter in each category of the categorical variable Type. The resulting bar chart is the same as the regular bar chart */ TITLE &#39;Barchart - bar&#39;; RUN; ODS GRAPHICS OFF; /**************************************** ** Topic 3: Scatter plot *****************************************/ * Example 3.1 - scatter plot - basic; ODS GRAPHICS ON / WIDTH = 4.5IN HEIGHT = 3.5IN; PROC SGPLOT DATA = Sashelp.cars; SCATTER X = MSRP Y = invoice; /* It doesn&#39;t matter which variable is X and which is Y. */ TITLE &#39;Scatter plot of MSRP vs Invoices&#39;; RUN; ODS GRAPHICS OFF; * Example 3.2 - scatter plot - by groups PROC SGPanel - allows making each for each category of the categorical the variable specified in the PANELBY statement; ODS GRAPHICS ON / WIDTH = 4.5IN HEIGHT = 3.5IN; PROC SGPANEL DATA = Sashelp.cars; PANELBY Type; /* The */ SCATTER X = MPG_Highway Y = MPG_City; TITLE &#39;Line plot of MSRP vs Invoices&#39;; RUN; ODS GRAPHICS OFF; * plot matrix: plot ; TITLE &quot;Scatter Plot Matrix Several Continuous Variables in CARS&quot;; ODS GRAPHICS ON / WIDTH = 4.5IN HEIGHT = 3.5IN; PROC SGSCATTER DATA =Sashelp.cars; MATRIX MSRP INVOICE HORSEPOWER MPG_CITY MPG_HIGHWAY / TRANSPARENCY = 0.6 /* degree of transparency of the plot */ ELLIPSE /* Add an ellipse to the data points to visualize the strength of the association between the two variables.*/ MARKERATTRS =(symbol=circlefilled) DIAGONAL=(histogram normal kernel); RUN; ODS GRAPHICS OFF; /************************************* ** Topic 4: Box-plots **************************************/ /** Example 4.1 Simple box-plot **/ TITLE &#39;Distribution of Mileage&#39;; ODS GRAPHICS ON / WIDTH =4.5IN HEIGHT=3.5IN; PROC SGPLOT DATA =sashelp.cars noautolegend; HBOX mpg_city ; /* Horizontal box-plot */ YAXIS GRID; /* DISPLAY is not specified. The default value of DISPLAY = (all): ticks, label and values are all displayed */ XAXIS DISPLAY = (nolabel); /* only the x-label is not displayed */ RUN; ODS GRAPHICS OFF; /** Example 4.2: Box-plot - by type **/ ODS GRAPHICS ON / WIDTH =4.5IN HEIGHT=3.5IN; TITLE &#39;Distribution of Mileage by Type&#39;; PROC SGPLOT DATA =sashelp.cars noautolegend; HBOX mpg_city / CATEGORY =type; YAXIS GRID; XAXIS DISPLAY = (nolabel); RUN; ODS GRAPHICS OFF; /** 4.3. Box-plot with a line plot connecting means **/ TITLE &#39;Mileage by Type&#39;; ODS GRAPHICS ON / WIDTH =4.5IN HEIGHT=3.5IN; /** control the size of the graphic **/ PROC SGPLOT DATA =sashelp.cars; /* vertical box-plot, opposed to horizontal box-plot with HBOX option */ VBOX mpg_city / CATEGORY =type /* The categorical to be used to */ CONNECT = mean /* connect the specified quantities of each category with a line segment */ DATALABEL; /* use observation ID of the data value if the value is an outlier */ XAXIS GRID DISPLAY = (noticks nolabel); /* whether ticks, label, values associated with the axis are displayed*/ YAXIS GRID DISPLAY = (novalues nolabel); RUN; ODS GRAPHICS OFF; /** Example 4.4. Multiple box-plots on the same plot **/ PROC SGPLOT DATA =sashelp.cars; VBOX enginesize / CATEGORY=type /* Make a box plot for each category of the character variable*/ BOXWIDTH=0.25 /* box width of the box-plot */ DISCRETEOFFSET = -0.15; /* the deviation of box-plot associated with variable enginesize to the left of the center of the category */ VBOX horsepower / CATEGORY=type BOXWIDTH=0.25 DISCRETEOFFSET=0.15 /* the deviation of the box-plot associated with variable enginesize to the right of the center of the category. The distance between the two box-plots is 0.15-(-0.15) = 0.3 */ 2AXIS; /* Make two vertical axes since two numerical variables are at different scales! */ RUN; /************************************* ** Topic 5: Regression Line **************************************/ /* Example 5.1. Scatter plot with a regression line */ TITLE &quot;Scatter Plot with Regression Line&quot;; PROC SGPLOT DATA = sashelp.cars; REG y = Horsepower x=Weight; /* y = response var, x = horizontal var */ RUN; /** Example 5.2. Regression with confidence limits **/ TITLE1 &quot;Scatter Plot with Regression Line&quot;; TITLE2 &quot;with Confidence Limits/Band&quot;; PROC SGPLOT DATA = sashelp.cars; REG y = Horsepower x=Weight/ CLI /* confidence limits of individual predicted values */ CLM /* confidence limit of the regression line - confidence band */ alpha=0.1; /* confidence level = 1 - 0.1 = 90%, default ALPHA = 0.05 */ RUN; /** Example 5.3. Regression with confidence limits **/ TITLE1 &quot;Scatter Plot with Regression Line&quot;; TITLE2 &quot;with Confidence Limits/Band, line/marker attributes&quot;; PROC SGPLOT DATA = sashelp.cars; REG y = Horsepower x=Weight/ CLI CLM alpha=0.1 lineattrs=(color=red thickness=5) markerattrs=(color=blue size=10 symbol=squarefilled); RUN; /************************************* ** Topic 6: Density function **************************************/ /* Example 6.1. calculate the mean and standard deviation and then use the mean and standard deviation to fit a normal distribution. The density curve will be placed on the histogram*/ TITLE &#39;Normal Density for Horsepower&#39;; ODS GRAPHICS ON / WIDTH = 4.5IN HEIGHT = 3.5IN; PROC SGPLOT DATA=sashelp.cars NOAUTOLEGEND; /* NOAUTOLEGEND: disables automatic legends from being generated. */ HISTOGRAM HORSEPOWER; DENSITY HORSEPOWER; YAXIS GRID; XAXIS DISPLAY = (nolabel); /* X-axis label is disabled. */ RUN; ODS GRAPHICS OFF; /**Example 6.2: Use a different variable: MSRP **/ TITLE &#39;Normal Density for MSRP&#39;; ODS GRAPHICS ON / WIDTH = 4.5IN HEIGHT = 3.5IN; PROC SGPLOT DATA=sashelp.cars NOAUTOLEGEND; /* By default, legends are created automatically for some plots, depending on their content. This option has no effect if you specify a KEYLEGEND statement. */ HISTOGRAM MSRP; DENSITY MSRP; YAXIS GRID; XAXIS DISPLAY = (nolabel); /* X-axis label is disabled. */ RUN; ODS GRAPHICS OFF; /** Example 6.3: kernel density curve **/ TITLE &#39;Normal Density for MSRP&#39;; ODS GRAPHICS ON / WIDTH = 4.5IN HEIGHT = 3.5IN; PROC SGPLOT DATA=sashelp.cars; *NOAUTOLEGEND; HISTOGRAM MSRP / SCALE = percent; DENSITY MSRP / SCALE = percent TYPE = Kernel; YAXIS GRID; XAXIS DISPLAY = (nolabel); RUN; ODS GRAPHICS OFF; /** Example 6.4. Kernel and normal density **/ TITLE &#39;Normal/Kernel Density for MSRP&#39;; ODS GRAPHICS ON / WIDTH = 4.5IN HEIGHT = 3.5IN; PROC SGPLOT DATA=sashelp.cars; HISTOGRAM MSRP / SCALE = percent; /* percent = relative frequency, This is the default scale in SAS */ DENSITY MSRP; DENSITY MSRP / TYPE = Kernel; KEYLEGEND / LOCATION =inside POSITION = topright ACROSS = 1; YAXIS GRID DISPLAY = (nolabel); XAXIS GRID DISPLAY = (nolabel); RUN; ODS GRAPHICS OFF; "],["subsetting-data.html", "Chapter 8 Subsetting Data 8.1 Selecting Columns 8.2 Selecting Rows 8.3 Subsetting by Splitting 8.4 Learning Coding by Examples", " Chapter 8 Subsetting Data Subsetting Data is a process of creating a smaller data set based on a larger data set. There are major methods for subsetting a data set: selecting and splitting. Selecting: We select/keep rows and columns from a data set to make a smaller data set. We can also delete rows and drop columns to make a smaller data set. Splitting: From the self-explanatory term, we can split a larger data set into several smaller data sets. This chapter discusses the above different methods with some examples. We will still use the penguin data set in illustrative examples. https://raw.githubusercontent.com/pengdsci/sta553/main/w02-penguins.csv FILENAME pguin URL &quot;https://raw.githubusercontent.com/pengdsci/sta553/main/w02-penguins.csv&quot;; PROC IMPORT DATAFILE = pguin OUT = penguin DBMS = CSV REPLACE; GETNAMES = YES; RUN; DATA new_penguin; /* define a new data set */ SET Penguin; /* copy the data original data*/ body_mass = input(body_mass_g, 8.); /* conversion */ flipper_length = input(flipper_length_mm, 8.); bill_depth = input(bill_depth_mm, 8.); bill_length = input(bill_length_mm, 8.); RUN; 8.1 Selecting Columns This subsetting method is straightforward. SAS statements KEEP and DROP to define a smaller data set. The new_penguin is defined based on the original penguin data set in which all numerical variables were defined in character form. We converted four character-encoded variables into numerical variables and added them to penguin with new names. We now drop variables bill_depth_mm, bill_length_mm, body_mass_g, and flipper_length_mm from the data set new_penguin and only keep only numerical version of these variables. DATA penguin01; SET new_penguin; DROP bill_depth_mm bill_length_mm body_mass_g flipper_length_mm; RUN; PROC CONTENTS DATA = penguin01; RUN; We can also use KEEP statement to subset the data set. DATA penguin02; SET new_penguin; KEEP bill_depth bill_length body_mass flipper_length island sex species year; RUN; PROC CONTENTS DATA = penguin02; RUN; 8.2 Selecting Rows Selecting columns is relatively straightforward. Working with rows is challenging since there are different ways of selecting rows under certain conditions. 8.2.1 Partial Reading Sometimes file movements have a size limit. For example, the file size in an email attachment should not be bigger than, say 15MB. If you have a 25 MB data file, we can use OBS= to read part of the data file and create two smaller data files. We have used OBS = and FIRSTOBS = in the previous chapter to read a data file with descriptions and comments. For example, we now define a data set by including observations 100 - 200 in the penguin02. DATA penguin03; SET penguin02(FIRSTOBS = 100 OBS = 200); RUN; PROC CONTENTS DATA = penguin03; RUN; 8.2.2 Conditional Selecting Methods This type of method uses conditional statements to select rows. Three keywords WHERE, IF-THEN, and IN are used to define conditions for selecting rows. 8.2.2.1 WHERE and IN We have used WHERE in the previous chapter on SAS graphics. For example, we create a subset that contains two of the three species: Chinstra and Gentoo. DATA penguin04; SET penguin02; WHERE (species = &#39;Chinstra&#39; OR species = &#39;Gentoo&#39;); RUN; PROC FREQ DATA = penguin04; TABLE species; TITLE &quot;Checking species in the new subset&quot;; RUN; title &quot;&quot; We can see that WHERE successfully subsets the data. We can also use IN statement to perform the same task. DATA penguin04; SET penguin02; WHERE species IN (&#39;Chinstra&#39; &#39;Gentoo&#39;); RUN; PROC FREQ DATA = penguin04; TABLE species; TITLE &quot; WHERE-IN: species in the new subset&quot;; RUN; title &quot;&quot; 8.2.2.2 IF-THEN-DELETE We can also delete those rows that we don’t want to include in the final subset by using the statement IF-THEN-DELETE. We next create the above data set penguin05 by deleting species Adelie DATA penguin05; SET penguin02; IF species = &#39;Adelie&#39; THEN DELETE; RUN; PROC FREQ DATA = penguin05; TABLE species; TITLE &quot; IF-THEN-DELETE: species in the new subset&quot;; RUN; title &quot;&quot; 8.3 Subsetting by Splitting We can split a large data set into several small data sets by using the conditional statement IF-THEN-OUTPUT. This allows us to define several subsets in a single data step. The next example shows how the split penguin02 into three subsets and each subset contains only one species. DATA Adelie Chinstra Gentoo; SET penguin02; IF species = &#39;Adelie&#39; THEN OUTPUT Adelie; IF species = &#39;Chinstra&#39; THEN OUTPUT Chinstra; IF species = &#39;Gentoo&#39; THEN OUTPUT Gentoo; RUN; The above log file indicates that three subsets are successfully defined. 8.4 Learning Coding by Examples This section provides numerous examples using different methods to subset data. One of the working data sets can be found at https://raw.githubusercontent.com/pengdsci/STA311/main/w07-us-counties.csv The last example uses automatic variables to subset data. /*************************************************************** Subsetting and Splitting Data Sets Topics 1. Subsetting Datasets by Conditional Processing 2. Subsetting Datasets by Rows 3. Splitting a Dataset 4. Subsetting Variables 5. Subsetting Rows with Auto Variables ***************************************************************/ DM &quot;CLEAR LOG&quot;; DM &quot;CLEAR OUT&quot;; OPTIONS PS = 76 LS = 76 NONUMBER NODATE; LIBNAME w07 &quot;C:\\STA311\\w07&quot;; /************************************************* This session focuses on subsetting SAS data sets using SAS keywords and SAS conditional statements. Most of the examples will be based on the following two working data sets. **************************************************/ /***********************************/ /* Working data set #1 */ /***********************************/ DATA auto ; LENGTH make $ 20 ; INPUT make $ 1-17 price mpg rep78 hdroom trunk weight length turn displ gratio foreign ; DATALINES; AMC Concord 4099 22 3 2.5 11 2930 186 40 121 3.58 0 AMC Pacer 4749 17 3 3.0 11 3350 173 40 258 2.53 0 AMC Spirit 3799 22 . 3.0 12 2640 168 35 121 3.08 0 Audi 5000 9690 17 5 3.0 15 2830 189 37 131 3.20 1 Audi Fox 6295 23 3 2.5 11 2070 174 36 97 3.70 1 BMW 320i 9735 25 4 2.5 12 2650 177 34 121 3.64 1 Buick Century 4816 20 3 4.5 16 3250 196 40 196 2.93 0 Buick Electra 7827 15 4 4.0 20 4080 222 43 350 2.41 0 Buick LeSabre 5788 18 3 4.0 21 3670 218 43 231 2.73 0 Buick Opel 4453 26 . 3.0 10 2230 170 34 304 2.87 0 Buick Regal 5189 20 3 2.0 16 3280 200 42 196 2.93 0 Buick Riviera 10372 16 3 3.5 17 3880 207 43 231 2.93 0 Buick Skylark 4082 19 3 3.5 13 3400 200 42 231 3.08 0 Cad. Deville 11385 14 3 4.0 20 4330 221 44 425 2.28 0 Cad. Eldorado 14500 14 2 3.5 16 3900 204 43 350 2.19 0 Cad. Seville 15906 21 3 3.0 13 4290 204 45 350 2.24 0 Chev. Chevette 3299 29 3 2.5 9 2110 163 34 231 2.93 0 Chev. Impala 5705 16 4 4.0 20 3690 212 43 250 2.56 0 Chev. Malibu 4504 22 3 3.5 17 3180 193 31 200 2.73 0 Chev. Monte Carlo 5104 22 2 2.0 16 3220 200 41 200 2.73 0 Chev. Monza 3667 24 2 2.0 7 2750 179 40 151 2.73 0 Chev. Nova 3955 19 3 3.5 13 3430 197 43 250 2.56 0 Datsun 200 6229 23 4 1.5 6 2370 170 35 119 3.89 1 Datsun 210 4589 35 5 2.0 8 2020 165 32 85 3.70 1 Datsun 510 5079 24 4 2.5 8 2280 170 34 119 3.54 1 Datsun 810 8129 21 4 2.5 8 2750 184 38 146 3.55 1 Dodge Colt 3984 30 5 2.0 8 2120 163 35 98 3.54 0 Dodge Diplomat 4010 18 2 4.0 17 3600 206 46 318 2.47 0 Dodge Magnum 5886 16 2 4.0 17 3600 206 46 318 2.47 0 Dodge St. Regis 6342 17 2 4.5 21 3740 220 46 225 2.94 0 Fiat Strada 4296 21 3 2.5 16 2130 161 36 105 3.37 1 Ford Fiesta 4389 28 4 1.5 9 1800 147 33 98 3.15 0 Ford Mustang 4187 21 3 2.0 10 2650 179 43 140 3.08 0 Honda Accord 5799 25 5 3.0 10 2240 172 36 107 3.05 1 Honda Civic 4499 28 4 2.5 5 1760 149 34 91 3.30 1 Linc. Continental 11497 12 3 3.5 22 4840 233 51 400 2.47 0 Linc. Mark V 13594 12 3 2.5 18 4720 230 48 400 2.47 0 Linc. Versailles 13466 14 3 3.5 15 3830 201 41 302 2.47 0 Mazda GLC 3995 30 4 3.5 11 1980 154 33 86 3.73 1 Merc. Bobcat 3829 22 4 3.0 9 2580 169 39 140 2.73 0 Merc. Cougar 5379 14 4 3.5 16 4060 221 48 302 2.75 0 Merc. Marquis 6165 15 3 3.5 23 3720 212 44 302 2.26 0 Merc. Monarch 4516 18 3 3.0 15 3370 198 41 250 2.43 0 Merc. XR-7 6303 14 4 3.0 16 4130 217 45 302 2.75 0 Merc. Zephyr 3291 20 3 3.5 17 2830 195 43 140 3.08 0 Olds 98 8814 21 4 4.0 20 4060 220 43 350 2.41 0 Olds Cutl Supr 5172 19 3 2.0 16 3310 198 42 231 2.93 0 Olds Cutlass 4733 19 3 4.5 16 3300 198 42 231 2.93 0 Olds Delta 88 4890 18 4 4.0 20 3690 218 42 231 2.73 0 Olds Omega 4181 19 3 4.5 14 3370 200 43 231 3.08 0 Olds Starfire 4195 24 1 2.0 10 2730 180 40 151 2.73 0 Olds Toronado 10371 16 3 3.5 17 4030 206 43 350 2.41 0 Peugeot 604 12990 14 . 3.5 14 3420 192 38 163 3.58 1 Plym. Arrow 4647 28 3 2.0 11 3260 170 37 156 3.05 0 Plym. Champ 4425 34 5 2.5 11 1800 157 37 86 2.97 0 Plym. Horizon 4482 25 3 4.0 17 2200 165 36 105 3.37 0 Plym. Sapporo 6486 26 . 1.5 8 2520 182 38 119 3.54 0 Plym. Volare 4060 18 2 5.0 16 3330 201 44 225 3.23 0 Pont. Catalina 5798 18 4 4.0 20 3700 214 42 231 2.73 0 Pont. Firebird 4934 18 1 1.5 7 3470 198 42 231 3.08 0 Pont. Grand Prix 5222 19 3 2.0 16 3210 201 45 231 2.93 0 Pont. Le Mans 4723 19 3 3.5 17 3200 199 40 231 2.93 0 Pont. Phoenix 4424 19 . 3.5 13 3420 203 43 231 3.08 0 Pont. Sunbird 4172 24 2 2.0 7 2690 179 41 151 2.73 0 Renault Le Car 3895 26 3 3.0 10 1830 142 34 79 3.72 1 Subaru 3798 35 5 2.5 11 2050 164 36 97 3.81 1 Toyota Celica 5899 18 5 2.5 14 2410 174 36 134 3.06 1 Toyota Corolla 3748 31 5 3.0 9 2200 165 35 97 3.21 1 Toyota Corona 5719 18 5 2.0 11 2670 175 36 134 3.05 1 Volvo 260 11995 17 5 2.5 14 3170 193 37 163 2.98 1 VW Dasher 7140 23 4 2.5 12 2160 172 36 97 3.74 1 VW Diesel 5397 41 5 3.0 15 2040 155 35 90 3.78 1 VW Rabbit 4697 25 4 3.0 15 1930 155 35 89 3.78 1 VW Scirocco 6850 25 4 2.0 16 1990 156 36 97 3.78 1 ; RUN; PROC CONTENTS DATA=auto; RUN; /***********************************/ /* Working data set #2 */ /* NYT COVID-19 */ /***********************************/ PROC IMPORT OUT= WORK.us_county_covid19 DATAFILE= &quot;C:\\STA311\\w07\\w07-us-counties.csv&quot; DBMS=CSV REPLACE; GETNAMES=YES; GUESSINGROWS=3000; /* Caution: if omitted, the default is 20 */ DATAROW=2; RUN; PROC CONTENTS DATA = us_county_covid19; RUN; /************************************************** Topic #1: Subsetting Datasets by Conditions Conditional keywords: 1. IF 2. IF-THEN-DELETE 3. IF-THEN-OUTPUT 4. WHERE ***************************************************/ PROC CONTENTS DATA = auto; RUN; /* IF condition */ DATA FOREIN_CARS01; SET AUTO; /* SAS data set */ IF FOREIGN =1; /* foreign = 1 (foreign), 0 (domestic) */ RUN; /* IF-THEN-DELETE */ DATA FOREIGN_CARS02; SET AUTO; IF FOREIGN = 0 THEN DELETE; /* deleting domestic cars */ RUN; /* IF-THEN-OUTPUT */ DATA FOREIGN_CARS03; SET AUTO; IF FOREIGN =1 THEN OUTPUT; RUN; /* WHERE */ DATA FOREIGN_CARS04; SET AUTO; WHERE FOREIGN = 1; RUN; /* IF statement can also be used in the data input step after INPUT statement. However, WHERE can not be used before the SAS data set is created, */ DATA FOREIGN_CARS05 ; LENGTH make $ 20 ; INPUT make $ 1-17 price mpg rep78 hdroom trunk weight length turn displ gratio foreign ; IF FOREIGN =1; /* WHERE does not work with INPUT statement */ DATALINES; AMC Concord 4099 22 3 2.5 11 2930 186 40 121 3.58 0 AMC Pacer 4749 17 3 3.0 11 3350 173 40 258 2.53 0 AMC Spirit 3799 22 . 3.0 12 2640 168 35 121 3.08 0 Audi 5000 9690 17 5 3.0 15 2830 189 37 131 3.20 1 Audi Fox 6295 23 3 2.5 11 2070 174 36 97 3.70 1 BMW 320i 9735 25 4 2.5 12 2650 177 34 121 3.64 1 Buick Century 4816 20 3 4.5 16 3250 196 40 196 2.93 0 Buick Electra 7827 15 4 4.0 20 4080 222 43 350 2.41 0 Buick LeSabre 5788 18 3 4.0 21 3670 218 43 231 2.73 0 Buick Opel 4453 26 . 3.0 10 2230 170 34 304 2.87 0 Buick Regal 5189 20 3 2.0 16 3280 200 42 196 2.93 0 Buick Riviera 10372 16 3 3.5 17 3880 207 43 231 2.93 0 Buick Skylark 4082 19 3 3.5 13 3400 200 42 231 3.08 0 Cad. Deville 11385 14 3 4.0 20 4330 221 44 425 2.28 0 Cad. Eldorado 14500 14 2 3.5 16 3900 204 43 350 2.19 0 Cad. Seville 15906 21 3 3.0 13 4290 204 45 350 2.24 0 Chev. Chevette 3299 29 3 2.5 9 2110 163 34 231 2.93 0 Chev. Impala 5705 16 4 4.0 20 3690 212 43 250 2.56 0 Chev. Malibu 4504 22 3 3.5 17 3180 193 31 200 2.73 0 Chev. Monte Carlo 5104 22 2 2.0 16 3220 200 41 200 2.73 0 Chev. Monza 3667 24 2 2.0 7 2750 179 40 151 2.73 0 Chev. Nova 3955 19 3 3.5 13 3430 197 43 250 2.56 0 Datsun 200 6229 23 4 1.5 6 2370 170 35 119 3.89 1 Datsun 210 4589 35 5 2.0 8 2020 165 32 85 3.70 1 Datsun 510 5079 24 4 2.5 8 2280 170 34 119 3.54 1 Datsun 810 8129 21 4 2.5 8 2750 184 38 146 3.55 1 Dodge Colt 3984 30 5 2.0 8 2120 163 35 98 3.54 0 Dodge Diplomat 4010 18 2 4.0 17 3600 206 46 318 2.47 0 Dodge Magnum 5886 16 2 4.0 17 3600 206 46 318 2.47 0 Dodge St. Regis 6342 17 2 4.5 21 3740 220 46 225 2.94 0 Fiat Strada 4296 21 3 2.5 16 2130 161 36 105 3.37 1 Ford Fiesta 4389 28 4 1.5 9 1800 147 33 98 3.15 0 Ford Mustang 4187 21 3 2.0 10 2650 179 43 140 3.08 0 Honda Accord 5799 25 5 3.0 10 2240 172 36 107 3.05 1 Honda Civic 4499 28 4 2.5 5 1760 149 34 91 3.30 1 Linc. Continental 11497 12 3 3.5 22 4840 233 51 400 2.47 0 Linc. Mark V 13594 12 3 2.5 18 4720 230 48 400 2.47 0 Linc. Versailles 13466 14 3 3.5 15 3830 201 41 302 2.47 0 Mazda GLC 3995 30 4 3.5 11 1980 154 33 86 3.73 1 Merc. Bobcat 3829 22 4 3.0 9 2580 169 39 140 2.73 0 Merc. Cougar 5379 14 4 3.5 16 4060 221 48 302 2.75 0 Merc. Marquis 6165 15 3 3.5 23 3720 212 44 302 2.26 0 Merc. Monarch 4516 18 3 3.0 15 3370 198 41 250 2.43 0 Merc. XR-7 6303 14 4 3.0 16 4130 217 45 302 2.75 0 Merc. Zephyr 3291 20 3 3.5 17 2830 195 43 140 3.08 0 Olds 98 8814 21 4 4.0 20 4060 220 43 350 2.41 0 Olds Cutl Supr 5172 19 3 2.0 16 3310 198 42 231 2.93 0 Olds Cutlass 4733 19 3 4.5 16 3300 198 42 231 2.93 0 Olds Delta 88 4890 18 4 4.0 20 3690 218 42 231 2.73 0 Olds Omega 4181 19 3 4.5 14 3370 200 43 231 3.08 0 Olds Starfire 4195 24 1 2.0 10 2730 180 40 151 2.73 0 Olds Toronado 10371 16 3 3.5 17 4030 206 43 350 2.41 0 Peugeot 604 12990 14 . 3.5 14 3420 192 38 163 3.58 1 Plym. Arrow 4647 28 3 2.0 11 3260 170 37 156 3.05 0 Plym. Champ 4425 34 5 2.5 11 1800 157 37 86 2.97 0 Plym. Horizon 4482 25 3 4.0 17 2200 165 36 105 3.37 0 Plym. Sapporo 6486 26 . 1.5 8 2520 182 38 119 3.54 0 Plym. Volare 4060 18 2 5.0 16 3330 201 44 225 3.23 0 Pont. Catalina 5798 18 4 4.0 20 3700 214 42 231 2.73 0 Pont. Firebird 4934 18 1 1.5 7 3470 198 42 231 3.08 0 Pont. Grand Prix 5222 19 3 2.0 16 3210 201 45 231 2.93 0 Pont. Le Mans 4723 19 3 3.5 17 3200 199 40 231 2.93 0 Pont. Phoenix 4424 19 . 3.5 13 3420 203 43 231 3.08 0 Pont. Sunbird 4172 24 2 2.0 7 2690 179 41 151 2.73 0 Renault Le Car 3895 26 3 3.0 10 1830 142 34 79 3.72 1 Subaru 3798 35 5 2.5 11 2050 164 36 97 3.81 1 Toyota Celica 5899 18 5 2.5 14 2410 174 36 134 3.06 1 Toyota Corolla 3748 31 5 3.0 9 2200 165 35 97 3.21 1 Toyota Corona 5719 18 5 2.0 11 2670 175 36 134 3.05 1 Volvo 260 11995 17 5 2.5 14 3170 193 37 163 2.98 1 VW Dasher 7140 23 4 2.5 12 2160 172 36 97 3.74 1 VW Diesel 5397 41 5 3.0 15 2040 155 35 90 3.78 1 VW Rabbit 4697 25 4 3.0 15 1930 155 35 89 3.78 1 VW Scirocco 6850 25 4 2.0 16 1990 156 36 97 3.78 1 ; RUN; /******************************************** Topic #2: Extracting Rows This method is usually used in conjunction with RPCO SORT and PROC FREQ. The following are a few examples. I am going to create the same data set: foreign_cars. We first create the SAS data set AUTO. *********************************************/ PROC SORT DATA = AUTO OUT = AUTO_SRT; BY DESCENDING FOREIGN; /* default sorting order is ASCENDING */ RUN; /** After sorting the data by FOREIGN in descending order, Foreign cars are on the top few rows, We next find the number of foreign cars before we use FIRSTOBS and OBS to extract the foreign cars **/ PROC FREQ DATA = AUTO_SRT; TABLE FOREIGN; RUN; /** The frequency table shows there are 22 foreign cars in the data **/ DATA FOREIGN_CARS06; SET AUTO_SRT(FIRSTOBS = 1 OBS = 22); RUN; /******************************************** Topic #3: Subsetting Variables -- KEEP and DROP statements *********************************************/ /** Create new data with 3 variables by keeping the 3 variables **/ DATA FEW_VAR_AUTO_01; SET AUTO; KEEP make price mpg; /* keep only 3 variables */ RUN; /** Create a new data with 3 variables by dropping the rest of the variables**/ DATA FEW_VAR_AUTO_02; SET AUTO; DROP rep78 hdroom trunk weight length turn displ gratio foreign; /* keep only 3 variables */ RUN; /***************************************************** Topic 4: Splitting Data Sets (Splitting by rows) &quot;Splitting an SAS dataset&quot; means to partition the big data set into several sub-datasets. &quot;Combining&quot; the partitioned datasets will get the original dataset. The following statements can be used for this purpose: 1. IF-THEN-OUTPUT 2. SELECT-WHEN-OTHERWISE-OUTPUT-END *****************************************************/ /** IF-THEN-OUTPUT **/ DATA Foreign Domestic; SET AUTO; IF FOREIGN = 1 THEN OUTPUT FOREIGN; IF FOREIGN = 0 THEN OUTPUT Domestic; RUN; /* SELECT-WHEN-OTHERWISE-OUTPUT-END */ DATA FOREIGN_SELECT DOMESTIC_SELECT; SET AUTO; SELECT(FOREIGN); WHEN(1) OUTPUT FOREIGN_SELECT; OTHERWISE OUTPUT DOMESTIC_SELECT; END; RUN; /* */ DATA FOREIGN_SELECT_01 DOMESTIC_SELECT_01; SET AUTO; SELECT(FOREIGN); WHEN(1) OUTPUT FOREIGN_SELECT_01; WHEN(0) OUTPUT DOMESTIC_SELECT_01; END; RUN; /* Caution: CLAUSES within SELECT-END statement must exhaust all values of the selected variable. That means you have to partition the input dataset into at least two sub-datasets if the SELECT-END statement is used. The following data step DOES NOT work! */ DATA FOREIGN_SELECT_02; SET AUTO; SELECT(FOREIGN); WHEN(1) OUTPUT FOREIGN_SELECT_02; END; RUN; /** If you are interested in extract a small subset defined based on a selected variable (we call this variable partition variable) that has more than two categories, you can use clause OTHERWISE to split the original data into two subsets. **/ PROC CONTENTS DATA = US_COUNTY_COVID19; RUN; /* Example: COVID-19 case count data: using SELECT-END statement Goal: extract PA data */ /* Find the exact string of the values of variable STATE */ PROC FREQ DATA = US_COUNTY_COVID19; TABLE STATE; RUN; /* Splitting: PA and OTHER_STATES */ DATA PA OTHER_STATES; SET US_COUNTY_COVID19;; SELECT (STATE); WHEN (&#39;Pennsylvania&#39;) OUTPUT PA; OTHERWISE OUTPUT OTHER_STATES; END; RUN; /** IN operator to select multiple values of a categorical variable **/ DATA PAneighbors; SET US_COUNTY_COVID19; IF STATE IN (&#39;Pennsylvania&#39; &#39;New Jersey&#39; &#39;Ohio&#39; &#39;New York&#39; &#39;West Virginia&#39; &#39;Maryland&#39; &#39;Delaware&#39;); RUN; PROC FREQ DATA =PAneighbors; TABLE STATE; RUN; /***************************************************** Topic 5: Splitting Data Sets (Splitting by rows) Using AUTOMATIC Variables: *****************************************************/ PROC SORT DATA = PAneighbors; BY STATE COUNTY DATE; RUN; DATA County_one_obs; SET PAneighbors; BY STATE COUNTY DATE; IF LAST.COUNTY; RUN; PROC FREQ DATA = County_one_obs; TABLE STATE; RUN; /********************************************************************** Concluding Remark: This note covered most of the splitting/subsetting methods using a data step. In the future, you will learn more advanced methods such as PROC SQL for subsetting and splitting data sets. ************************************************************************/ "],["combining-data-sets.html", "Chapter 9 Combining Data Sets 9.1 Stacking/Concatenating 9.2 IN Statement and ghost Variable 9.3 Interleaving Data Sets 9.4 Merging by Matching 9.5 Summary of Some KEY Words and Statements 9.6 Learning Coding by Examples", " Chapter 9 Combining Data Sets In real-world applications, aggregating information from different data sources is a routine job for data and analytic professionals. There are two basic types of ways of combining data sets. Before we move to individual combining methods, we use the following flowchart to explain the process of how the data step creates SAS data records. Next, we create 5 working data sets based on the penguin data using the following code. FILENAME pguin URL &quot;https://raw.githubusercontent.com/pengdsci/sta553/main/w02-penguins.csv&quot;; PROC IMPORT DATAFILE = pguin OUT = penguin DBMS = CSV REPLACE; GETNAMES = YES; RUN; DATA numeric_penguin; /* define a new data set */ SET Penguin; /* copy the data original data*/ body_mass = input(body_mass_g, 8.); /* conversion */ flipper_length = input(flipper_length_mm, 8.); bill_depth = input(bill_depth_mm, 8.); bill_length = input(bill_length_mm, 8.); ID = VAR1; KEEP ID body_massflipper_length bill_depth bill_length; RUN; DATA char_penguin; SET penguin; ID = VAR1; DROP VAR1; RUN; DATA Adelie Chinstra Gentoo; SET penguin; IF species = &#39;Adelie&#39; THEN OUTPUT Adelie; IF species = &#39;Chinstra&#39; THEN OUTPUT Chinstra; IF species = &#39;Gentoo&#39; THEN OUTPUT Gentoo; RUN; A glance at the four working data sets is given in the following figure. 9.1 Stacking/Concatenating To append the observations from one data set to another data set, we concatenate them by specifying the data set names in the SET statement. When SAS concatenates, data sets in the SET statement are read sequentially, in the order in which they are listed. The new data set contains all the variables and the total number of observations from all input data sets. The syntax is DATA concat; SET dataset_a dataset_b; RUN; This above code assumes that both data sets have the same variables with the same names. If the same variable with different names, the resulting data set will treat the variables with different names as two different variables, therefore, missing values will be produced. Similarly, if a variable is not in one of the source data sets, the resulting data set will also end up with missing values. In case of the same variable with different names, we can use REMAE = (old_name = new_name) to rename any variable. At the same time, we may also need to include an indicator variable in the resulting data set to indicate the source of every record. /* sex in different data sets has different names */ DATA combined_penguin; SET Adelie(RENAME=(Adelie_sex = sex)) Chinstra(RENAME=(Chinstra_sex = sex)) Gentoo(RENAME=(Gentoo_sex = sex)); RUN; PROC PRINT DATA = combined_penguin; RUN; The resulting combined data set is given below. We can see that the names of sex variables in different data sets have been changed to sex. 9.2 IN Statement and ghost Variable The issue in the previous combined data set is that the species information is lost. We need to bring that information back to the data set. Therefore different ways to bring this information back. One way to do this is to add a species variable in the individual data sets before concatenating them. The other way is to use IN = to bring an invisible ghost indicator variable. The reason I call it a “ghost” variable is because you cannot print it out and view the variable! However, we can define the variable explicitly pick up the values of the ghost variable, and print the explicitly defined variable to see the values of the ghost variable. /* sex in different data sets has different names */ DATA combined_penguin; SET Adelie(RENAME=(Adelie_sex = sex) IN = Adelie) Chinstra(RENAME=(Chinstra_sex = sex) IN = Chinstra) Gentoo(RENAME=(Gentoo_sex = sex) IN = Gentoo); RUN; TITLE &quot;IN Statement - implicit indicator&quot;; PROC PRINT DATA = combined_penguin; RUN; IN statement defined an indicator variable but it did not appear in the combined data set. But we can use the value of the invisible indicator to define the actual species variable using a conditional statement (IF-THEN) as explained in the following code. /* sex in different data sets has different names */ DATA combined_penguin; SET Adelie(RENAME=(Adelie_sex = sex) IN = Adelie) Chinstra(RENAME=(Chinstra_sex = sex) IN = Chinstra) Gentoo(RENAME=(Gentoo_sex = sex) IN = Gentoo); IF Adelie THEN species = &#39;Adelie&#39;; IF Chinstra THEN species = &#39;Chinstra&#39;; IF Gentoo THEN species = &#39;Gentoo&#39;; RUN; TITLE &quot;IN Statement joint with IF-THEN&quot;; PROC PRINT DATA = combined_penguin; RUN; The above printout indicates that the variable `species ’ has been successfully added to the combined data set. 9.3 Interleaving Data Sets If we use a BY statement when you concatenate data sets, the result is interleaving. Interleaving intersperses observations from two or more data sets, based on one or more common variables. Each input data set must be sorted or indexed in ascending order based on the BY variable(s). The observations in the interleaved data sets are not combined; they are copied from the original data sets in the order of the values of the BY variable. Observations in each BY group in each data set in the SET statement are read sequentially, in the order in which the data sets and BY variables are listed until all observations have been processed. Observations in the output data set are arranged by the values of the BY variable. The new data set contains all the variables and the total number of observations from all input data sets. The general syntax is DATA interlv; SET dataset_a dataset_b; BY num; RUN; The following is a toy example. DATA Animal; INPUT common $ animal $; DATALINES; a Ant a Ape b Bird c Cat d Dog e Eagle ; RUN; DATA plant; INPUT common $ plant $; DATALINES; a Apple b Banna c Coconut c Celery d Dewberry e Eggplant ; RUN; * Sort the data by the common variable; PROC SORT DATA = Animal; BY Common; RUN; PROC SORT DATA = plant; BY common; RUN; DATA InterleaveData; SET animal plant; BY common; RUN; TITLE &quot;Interleaving Data Sets&quot;; PROC PRINT DATA = InterleaveData; RUN; The output data set This method is commonly used in creating longitudinal data sets. 9.4 Merging by Matching Sometimes we need to combine observations from two or more data sets into a single observation in a new data set according to the values of a same-named variable. This is match-merging, which uses a MERGE statement rather than a SET statement to combine data sets. Each input data set must be sorted or indexed in ascending order based on the BY variable(s). During match-merging, SAS sequentially checks each observation of each data set to see whether the BY values match, then writes the combined observation to the new data set. We next merge the combined penguin data set and the 4th penguin data set with only numerical variables. Since the numerical variables in the 4th data set have their corresponding character variables, we will drop these character variables that have their corresponding numerical version. We can do this by dropping these character variables first and then merging them. Next, we will do this by dropping when merging. **Keep in mind that we must sort the by-variable when we use the BY statement. PROC SORT DATA = combined_penguin; BY ID; RUN; PROC SORT DATA = numeric_penguin; BY ID; RUN; /** merge two data sets **/ DATA merge_data; MERGE combined_penguin numeric_penguin; BY ID; DROP flipper_length_mm body_mass_g bill_depth_mm bill_length_mm; RUN; TITLE &quot;Merge Data&quot;; PROC PRINT DATA = merge_data; RUN; 9.5 Summary of Some KEY Words and Statements Execution of Merging: After compiling the DATA step, SAS sequentially match-merges observations by moving the pointers down each observation of each data set and checking to see whether the BY values match. If Yes, the observations are written to the PDV (program data vector) in the order in which the data sets appear in the MERGE statement. Values of any same-named variable are overwritten by values of the same-named variable in subsequent data sets. SAS writes the combined observation to the new data set and retains the values in the PDV until the BY value changes in all the data sets. If No, SAS determines which of the values comes first and writes the observation that contains this value to the PDV. Then the observation is written to the new data set. When the BY value changes in all the input data sets, the PDV is initialized to missing. The DATA step merge continues to process every observation in each data set until it has processed all observations in all data sets. Handling Unmatched Observations and Missing Values: All observations that are written to the PDV, including observations that have missing data and no matching BY values, are written to the output data set. If an observation contains missing values for a variable, then the observation in the output data set contains the missing values as well. Observations that have missing values for the BY variable appear at the top of the output data set. If an input data set doesn’t have a matching BY value, then the observation in the output data set contains missing values for the variables that are unique to that input data set. Renaming Variables: Sometimes you might have same-named variables in more than one input data set. In this case, match-merging overwrites values of the same-named variable in the first data set with values of the same-named variable in subsequent data sets. To prevent overwriting, use the RENAME= data set option in the MERGE statement to rename variables Excluding Unmatched Observations By default, match-merging combines all observations in all input data sets. However, we might want to select only observations that match two or more input data sets. To exclude unmatched observations, use the IN = data set option and the subsetting IF statement in your DATA step. The IN = data set option creates a variable (‘ghost’ variable because you cannot see it) to indicate whether the data set contributed data to the current observation. The subsetting IF statement then checks the IN = values and writes to the merged data set only observations that appear in the data sets for which IN = is specified. Selecting Variables: We can specify the variables you want to drop or keep by using the DROP = and KEEP = data set options. When match-merging, you can specify these options in either the DATA statement or the MERGE statement, depending on whether or not you want to process values of the variables in that DATA step. When used in the DATA statement, the DROP = option simply drops the variables from the new data set. However, they are still read from the original data set and are available within the DATA step. Summary We can rename any number of variables in each occurrence of the RENAME = option. In match-merging, the IN = data set option can apply to any data set in the MERGE statement. The RENAME =, DROP =, and KEEP = options can apply to any data set in the DATA or MERGE statements. Use the KEEP = option instead of the DROP = option if more variables are dropped than kept. When we specify multiple data set options for a particular data set, enclose them in a single set of parentheses. 9.6 Learning Coding by Examples The following examples explain most of the methods of combining data sets. Some new statements and keywords are also used in some of these examples. The related working data sets can be found using the following URLs: https://raw.githubusercontent.com/pengdsci/STA311/main/w07-us-counties.csv https://raw.githubusercontent.com/pengdsci/STA311/main/w08-Edu01.csv https://raw.githubusercontent.com/pengdsci/STA311/main/w08-Unemp01.csv https://raw.githubusercontent.com/pengdsci/STA311/main/w08-PovEst01.csv /*********************************************************** Merging SAS Data Sets Topics: 1. Concepts of a relational database- primary key 2. One-to-one reading: Use with caution! 3. concatenating 4. Interleaving 5. Match-merging 6. Data set options in the merging process: (1) renaming variables (2) excluding unmatched observations (3) Selecting variables ***************************************************************/ DM &#39;CLEAR OUT&#39;; DM &#39;CLEAR LOG&#39;; /****** Permanent Library *****/ LIBNAME my311 &quot;C:\\STA311\\w08&quot;; OPTIONS PS = 94 LS =75 NONUMBER NODATE; /*************************************************** Topic 1: one-to-one reading ****************************************************/ /* Let&#39;s first use two tiny datasets to show the process of one-to-one reading */ DATA one; INPUT ID VarA $ VarB $; DATALINES; 10 A1 B1 20 A2 B2 30 A3 B3 ; RUN; DATA two; INPUT ID VarB $ VarC $; DATALINES; 40 B4 C1 50 B5 C2 ; RUN; /** Here is the process: Two common variables (ID and VarB) are in both datasets Step 1: SAS picks the first record in the data set ONE and puts it in the input buffer: ID VarA VarB VarC 10 A1 B1 . Step 2: SAS picks the first record in data set TWO to put in the buffer and creates the first record in the combined data set. Here is what SAS actually does in the 2nd step (1). The values of the common variables will be overwritten by the corresponding values in the same row of the second data set. (2). The total number of rows will be equal to the smaller number of rows in the two data sets. Based on the above reading process, the first complete record in the combined the data set should be of the following form: ID VarA VarB VarC 40 A1 B4 C1 (overwritten) (overwritten) Step 3: SAS picks up the 2nd record from ONE and puts it in the buffer ID VarA VarB VarC 20 A2 B2 . Step 4: SAS moves to TWO picks up the 2nd record and repeats step 2. After fishing over-writing, the 2nd complete record in the combined data set will have the following form: ID VarA VarB VarC 50 A2 B5 C2 (overwritten) (overwritten) SAS will stop reading since TWO has only two rows: The final combined set has two records: ID VarA VarB VarC 40 A1 B4 C1 50 A2 B5 C2 **/ DATA onetwo; SET one; SET two; RUN; PROC PRINT DATA = onetwo; TITLE &quot;ONE 2 TWO&quot;; RUN; /** Example 2: Because of the way SAS processes the one2one reading by updating the values of the common variables with the ones in the second dataset, you will get different combined if you reverse the order of the two SET statements!!! **/ DATA twoone; SET two; SET one; RUN; PROC PRINT DATA = twoone; TITLE &quot;TWO 2 ONE&quot;; RUN; /** Example 3: A slightly larger data set. You should be able to figure out when you can use one-to-one reading methods to create a combined dataset correctly! **/ DATA one2oneread; SET patients; SET scale; RUN; PROC PRINT NOOBS; TITLE &#39;The one2oneread data set&#39;; RUN; /***************************************************************** Topic 2: Concatenating *****************************************************************/ /** Example 1. Simple stacking- all datasets have the same variable names, types ... **/ DATA one; INPUT ID VarA $ VarB $; DATALINES; 10 A1 B1 20 A2 B2 30 A3 B3 ; RUN; DATA two; INPUT ID VarB $ VarA $; DATALINES; 40 B4 A4 50 B5 A5 ; RUN; DATA Concatenate_1_2; SET one two; RUN; PROC PRINT DATA = Concatenate_1_2; TITLE &quot;Stacking with same variable names, type, length, ...&quot;; RUN; /** Example 2. Two data sets have the same type of information but with different variable names. You have two different ways to combine these types of data sets: (1). Create a new data set based on one of the data sets and make variables with the same name, types, and length first, then concatenate the two data sets (2). Use the RENAME option to rename the variables in the data step of concatenating two or more data sets **/ DATA data_one; INPUT Subj VariableA $ VarB $; DATALINES; 10 A1 B1 20 A2 B2 30 A3 B3 ; RUN; DATA data_two; INPUT ID VarB $ VarA $; DATALINES; 40 B4 A4 50 B5 A5 ; RUN; /* We use the RENAME option in the following data step to stack the two data sets with different variable names RENAME = (old1=new1 old2=new2 .... oldk=newk); */ DATA Concat_one_two; SET data_one (RENAME = (SUBJ=ID VariableA = VarA)) data_two; RUN; QUIT; PROC PRINT DATA = Concat_one_two; TITLE &quot;Concatenating datasets: with rename option&quot;; RUN; /** Example 3. We can also stack two or more data sets with different variables but with a set of common variables (maybe with different names) that will be combined in a new data set. Options RENAME and DROP can be used in the data step. We expect the combined data set to have ID and VarB only! **/ DATA Dataone; INPUT SUBJ VarA $ VariableB $ VarD $; DATALINES; 10 A1 B1 D1 20 A2 B2 D2 30 A3 B3 D3 ; RUN; DATA Datatwo; INPUT ID VarB $ VarC $; DATALINES; 40 B4 C1 50 B5 C2 ; RUN; DATA Dataone_datatwo; /** DROP = var1 var2 (no parenthesis is needed for a list of multiple variables!!!) **/ SET dataone(RENAME = (SUBJ=ID VariableB=VarB) DROP = VarA VarD) datatwo(DROP = VarC); RUN; PROC PRINT DATA = Dataone_datatwo; TITLE &quot;STacking: RENAME and DROP options&quot;; RUN; /************************************************************************** Topic 3: Merging data set - interleaving data sets **************************************************************************/ DATA DataA; INPUT year x; DATALINES; 2000 1 2003 4 2001 2 2002 3 ; RUN; DATA DataB; INPUT year x; DATALINES; 2001 5 2002 6 2003 7 2004 8 ; RUN; /** Caution: Whenever using the BY statement, you have to SORT the data first! **/ PROC SORT DATA = DataA; BY year; RUN; PROC SORT DATA = DataB; BY Year; RUN; /** interleaving the two sorted data sets **/ DATA DataC; SET DataA DataB; BY year; RUN; PROC PRINT DATA = DataC NOOBS; TITLE &#39;The interleaved three data set&#39;; RUN; /************************************************************************** Topic 4: Merging by Matching ***************************************************************************/ /** Example 1. Simple match-merging **/ DATA demog; INPUT subj gender $ age; DATALINES; 1000 M 42 1001 M 20 1002 F 53 1003 F 40 1004 M 29 ; RUN; DATA status; INPUT subj disease $ test $ ; DATALINES; 1000 Y Y 1001 N Y 1002 N N 1003 Y Y 1004 N N ; RUN; /** Caution: It is always a good practice to sort the source datasets before match-merge the data sets. In our example, the source data sets were naturally ordered by year. We can simply match-merge the source data sets **/ PROC SORT DATA = demog; BY subj; RUN; PROC SORT DATA = status; BY subj; RUN; DATA patients; MERGE demog status; BY subj; RUN; PROC PRINT DATA=patients NOOBS; TITLE &#39;The patients&#39; data set&#39;; RUN; /** Example 2. Match-merge two datasets and exclude unmatched observations: Consider a situation: You have large data sets with many patients&#39; data. We only extract a subset of the data set based on a given subset of patients. **/ DATA allvoids; /** the large data set with more patients&#39; data **/ INPUT id v_date : mmddyy8. void_no volume; FORMAT v_date mmddyy8.; DATALINES; 110011 01/01/06 1 250 110011 01/01/06 2 300 110011 01/01/06 3 302 110011 01/01/06 4 231 110012 01/02/06 1 305 110012 01/02/06 2 225 110012 01/02/06 3 400 110013 01/04/06 1 300 110013 01/04/06 2 333 110013 01/04/06 3 401 110013 01/04/06 4 404 110014 01/06/06 1 398 110014 01/06/06 2 413 ; RUN; /** subset of patients to be included in an analysis **/ DATA patients; INPUT id v_date : mmddyy8.; /* informat */ FORMAT v_date mmddyy8.; /* display format */ DATALINES; 110011 01/01/06 110012 01/02/06 110013 01/04/06 ; RUN; /** If the two sets are merged by matching the two KEYs (ID and V_date) **/ DATA analysis; MERGE patients allvoids; BY id v_date; RUN; PROC PRINT DATA=analysis NOOBS; TITLE &#39;The analysis data set&#39;; RUN; /** The resulting datasets still have data for other patients!! **/ /************************************************************************ IN option! *************************************************************************/ /** One way to fix this problem is to introduce new variables to indicate each individual record coming from the corresponding source data sets. IN = option will do the trick. DASET01 (IN = FRMdata01): FRMdata01 is a &quot;ghost&quot; indicator variable in in the resulting dataset: FRMdata01 = 1, the record is from DASET01, FRMdata01 = 0, the record is NOT from DASET01. The reason I call it a &quot;ghost&quot; variable is because we cannot print it out and view the variable! However, you can define variables explicitly and pick up the values of the &quot;ghost&quot; variable and print the explicitly defined variable to see the values of the &quot;ghost&quot; variable. Although you cannot see the &quot;ghost&quot; variable, you can use it to define conditional statements. **/ /** Example 3: &quot;ghost&quot; variables! **/ DATA ghost_variables; MERGE patients (IN = inpatients) allvoids (IN = inallvoids); BY id v_date; RUN; PROC PRINT DATA = ghost_variables;* NOOBS; TITLE &#39;Cannot see the &quot;ghost&quot; variables!! &#39;; RUN; /** Example 4: View the values of the &quot;ghost&quot; variables!! **/ DATA ghost_views; MERGE patients (IN = inpatients) allvoids (IN = inallvoids); BY id v_date; ghost01 = inpatients; /* Add ghost01 to the resulting data set */ ghost02 = inallvoids; /* Add ghost02 to the resulting data set */ /** We will study methods of manipulating datasets. Adding a variable to an existing data set is one of the topics!! **/ RUN; PROC PRINT DATA = ghost_views;* NOOBS; TITLE &#39;View the values of the &quot;ghost&quot; variable!!!&#39;; RUN; /** Example 5: Define the required data sets that have on patients in the patients&#39; dataset. Using the explicit indicator variables!!!! **/ DATA final_data_with_explicit_dummy; MERGE patients (IN = inpatients) allvoids (IN = inallvoids); BY id v_date; ghost01 = inpatients; ghost02 = inallvoids; IF ghost01 = ghost02; DROP ghost01 ghost02; /* DROPPING the explicit dummy variables */ RUN; PROC PRINT DATA = final_data_with_explicit_dummy; TITLE &quot;Final Data: Using explicit indicator variables&quot;; RUN; /** Example 6: Define the required data sets that have on patients in the patients&#39; dataset. Using the implicit ghost variables! **/ DATA final_data_with_inplicit_ghosts; MERGE patients (IN = inpatients) allvoids (IN = inallvoids); BY id v_date; IF inpatients = inallvoids; /* only keep records where both ghost variables are equal! */ RUN; PROC PRINT DATA = final_data_with_inplicit_ghosts; TITLE &quot;Final Data: Using explicit ghost variables&quot;; RUN; /***************************************************************************** Topic 5: Working with the real-world data COVID-19 DATA SET ******************************************************************************/ /** import all relevant data sets **/ PROC IMPORT OUT= county_covid DATAFILE= &quot;C:\\STA311\\w08\\w07-us-counties.csv&quot; DBMS=CSV REPLACE; GETNAMES=YES; GUESSINGROWS = 30000; DATAROW=2; RUN; PROC IMPORT OUT= edu01 DATAFILE= &quot;C:\\STA311\\w08\\w08-Edu01.csv&quot; DBMS=CSV REPLACE; GETNAMES=YES; GUESSINGROWS = 30000; DATAROW=2; RUN; PROC IMPORT OUT= unemploy DATAFILE= &quot;C:\\STA311\\w08\\w08-Unemp01.csv&quot; DBMS=CSV REPLACE; GETNAMES=YES; GUESSINGROWS = 30000; DATAROW=2; RUN; PROC IMPORT OUT= poverty DATAFILE= &quot;C:\\STA311\\w08\\w08-PovEst01.csv&quot; DBMS=CSV REPLACE; GETNAMES=YES; GUESSINGROWS = 30000; DATAROW=2; RUN; /** checking the contents of the SAS data sets created in the above procedures **/ PROC CONTENTS DATA = county_covid; RUN; PROC CONTENTS DATA = edu01; RUN; PROC CONTENTS DATA = unemploy; RUN; PROC CONTENTS DATA = poverty; RUN; /*** Covid-19 1.cases 2.county 3.date 4.deaths 5.fips 6.state Edu 1.ASDeg 2.BSplus 3.BelowHS 4.County 5.FIPSCode 6.HSonly 7.State Unemployment 1.FIPStxt 2.Med_income_18 3.Stabr 4.Unemp_rate_19 5.area_name Poverty 1. Area_name 2.FIPStxt 3.PCTPOV017_2018 4.PCYPOC517_2018 5.PCTPOVALL_2018 6.Stabr ***/ /** Every county had many records: we created a subset to include on the record on Sept. 27, 2020 **/ DATA COVID19_CURRENT; SET county_covid; IF DATE = &#39;27SEP2020&#39;d; /* */ KEEP FIPS CASES DEATHS county; RUN; /** FIPSCode is the primary key **/ PROC SORT DATA =COVID19_CURRENT; BY FIPS; RUN; /** FIPS is the primary key: need to rename FIPSCode as FIPS **/ DATA EDUCATION; SET EDU01(RENAME=(FIPSCode=FIPS)); RUN; PROC SORT DATA = EDUCATION; BY FIPS; RUN; /** FIPS is the primary key: need to rename FIPStext as FIPS **/ DATA UNEMPLOYMENT; SET unemploy (RENAME=(FIPStxt=FIPS)); DROP Stabr; RUN; PROC SORT DATA =UNEMPLOYMENT; BY FIPS; RUN; /** FIPS is the primary key: need to rename FIPStext as FIPS **/ DATA Poverty_01; SET poverty(RENAME=(FIPStxt=FIPS)); DROP stabr; RUN; PROC SORT DATA = Poverty_01; BY FIPS; RUN; /** FIPS is the primary key. Hidden dummy variables are logical **/ DATA Analytic_data; MERGE COVID19_CURRENT(IN = ghost1) EDUCATION(IN = ghost2) UNEMPLOYMENT(IN = ghost3 ) Poverty_01(IN = ghost4); BY FIPS; IF ghost1 * ghost2 * ghost3 * ghost4 = 1; /* Keep all FIPS that have a complete or partial record in all four data sets */ RUN; /****************************************************************** There are a lot of different methods to combine data sources using different tools. Some of them are more effective than others. These methods will be introduced in more advanced SAS programming or other database programming such as MySQL. SAS PROC SQL uses the standard SQL syntax. *******************************************************************/ "],["modifying-data.html", "Chapter 10 Modifying Data 10.1 SAS Functions: Date and Others 10.2 Automatic Variables 10.3 Calculating New Variables 10.4 Logical Expressions 10.5 Operators with WHERE statement 10.6 Learning Coding by Examples", " Chapter 10 Modifying Data In the previous chapter, we introduced methods for manipulating data by either entire rows or entire columns. This chapter will introduce methods for data manipulation by accessing cell elements inside a data table and defining/modifying new variables. Methods include handling SAS dates and times, using automatic variables, calculating new variables, using logical expressions and operators with WHERE statements, etc. 10.1 SAS Functions: Date and Others Handling SAS dates and times can be a challenging task in data manipulation. There are many different SAS date formats. The most commonly used ones are listed below. date format 09/19/07 MMDDYY8. 09-19-07 MMDDYY8. 09+19,07 MMDDYY8. 19SEP07 DATE7. 091907 MMDDYY6. 09/19/2007 MMDDYY10. 19/09/07 DDMMYY8. September 19, 2007 WORDDATE. Wed, Sept, 19, 2007 WEEKDATE It is not uncommon that the source data file contains three separate variables representing day, month, and year respectively. Example: Creating a SAS date from month, day, and year. 10.1.1 Using Date Functions We can use the SAS date function to define new variables. For example 10.1.2 Other Related SAS Functions The following are some of the functions that are commonly used in data manipulation. We have used input() to convert a character variable to a numeric variable. We could also use put() to convert a numerical variable to a character variable. 10.2 Automatic Variables Automatic variables are created automatically by the DATA step or by DATA step statements. These variables are added to the program data vector but are not written to the output data set. The values of automatic variables are retained from one iteration of the DATA step to the next, rather than set to missing There are many automatic variables in SAS, the following 4 are very commonly used in data manipulation. _N_ is an implicit counter. The other three automatic variables are binary logical variables. In the following example, we use _N_ to define an observation ID variable and add it to the data.FIRST.var and LAST.var are used to detect whether an observation is the first or last within the individual group of the categorical variable. DATA pets1; INPUT @1 name $9. @10 time time5. @20 date mmddyy8. @30 species $; mistakes=_error_; /* New variable mistakes=1 if error in reading obs*/ DATALINES; Fluffy 9:00 02/13/98 cat Tom 10:00 02/13/98 cat Rex 13:00 02/31/98 dog Fido 14:00 02/13/98 dog Felix 9:30 02/13/98 cat Spot 15:00 02/13/98 dog ; RUN; PROC SORT data=pets1; BY species time; RUN; DATA pets1; /* Make changes to dataset PETS1. */ SET pets1; BY species; pet_num=_n_; /* Pet number equal to observation number */ firstgrp=first.species; /* firstgrp=1 if first obs of each species*/ lastgrp=last.species; /* lastgrp=1 if last obs of each species */ RUN; TITLE &quot;Defining new variables using automatic variables&quot;; PROC PRINT data=pets1; VAR pet_num name species time date mistakes firstgrp lastgrp; FORMAT time time5. date mmddyy8.; RUN; We can also use automatic variables in a conditional statement to subset a given data set. For example, 10.3 Calculating New Variables To define new variables using basic mathematical operations and functions. Many mathematical functions are built in base SAS. The following are very commonly used. Newvar = log(var1); value is natural logarithm of var1 Newvar = log10(var1); value is common logarithm of var1 Newvar = log2(var1); value is base 2 logarithm of var1 Newvar = sqrt(var1); value is square root of var1 Newvar = mdy(month, day, year); create SAS date variable from individual month, day, and year values. Newvar = abs(var1); value is the absolute value of var1 10.4 Logical Expressions We have used logical expressions in conditional statements used in subsetting data sets. The general structure of a logical expression is similar to the following example. IF logical_condition_true THEN action_1; ELSE action_2; It is critical to use logical operations correctly in logical expressions. Logical operators: EQ equals (=) NE not equal (~=, ^=) GT greater than (&gt;) LT less than (&lt;) GE greater than or equal to (&gt;=) LE less than or equal to (&lt;=) AND all comparisons must be true (&amp;) OR only one comparison must be true (!, |) Actions: ANY SAS DATA or MACRO statement (e.g. another assignment, IF, DO …) The following example uses EQ for logical operation and = for assignment operation. 10.5 Operators with WHERE statement The WHERE statement selects observations in SAS data sets only, whereas the subsetting IF statement selects observations from an existing SAS data set or from observations that are created with an INPUT statement. WHERE is one of the most powerful statements in SAS. WHERE can be used jointly with many other operators to make more powerful data operations. This section introduces operators that are commonly used with the WHERE statement. 10.5.1 WHERE-BETWEEN-AND Example, 10.5.2 WHERE-CONTAINS or ? Example 10.5.3 WHERE-IS MISSING or IS NULL 10.5.4 WHERE-LIKE Example, 10.5.5 WHERE =* Example, 10.6 Learning Coding by Examples This section provides a few examples that illustrate the topics introduced in previous sections. One external data set used in the following example can be found at https://raw.githubusercontent.com/pengdsci/STA311/main/w07-us-counties.csv /********************************************************* Topics: 1. SAS Date and Time Functions 2. Automatic Variables 3. Defining New Variables 4. Variable type conversion 5. Use of Logical Expressions 6. Operators with WHERE statement 7. Real-world application **********************************************************/ LIBNAME my311 &quot;C:\\STA311\\w09&quot;; OPTIONS PS = 76 LS = 76 NONUMBER NODATE; DM &quot;CLEAR LOG&quot;; DM &quot;Clear OUT&quot;; /************************************************/ /** Topic #1. More on Date and Date functions **/ /************************************************/ /* Example 1: MDY() is a SAS built-in function. We can use it to define (ensemble) an SAS date. */ DATA MDY_FUNCTION; INPUT DAY MONTH YEAR; DOB = MDY(MONTH, DAY, YEAR); FORMAT DOB WORDDATE.; DATALINES; 12 11 1992 11 9 1999 13 10 2007 12 10 7 ; RUN; PROC PRINT DATA = MDY_FUNCTION; RUN; /** Example 2: Commonly used Date formats/informats. CAUTION: When a fixed date is used in any conditional statement, the only formats we can specify are in the &#39;ddMONyy&#39;d or &#39;ddMONyyyy&#39;d. No other forms will work! **/ DATA More_Date_Formats; SET MDY_FUNCTION; DATE01 = DOB; DATE02 = DOB; DATE03 = DOB; DATE04 = DOB; DATE05 = DOB; DATE06 = DOB; DATE07 = DOB; FORMAT DATE01 MMDDYY8. DATE02 DDMMYY8. DATE03 MMDDYY10. DATE04 DDMMYY10. DATE05 DATE7. DATE06 MMDDYY6. DATE07 WEEKDATE.; DROP DAY MONTH YEAR; RUN; PROC PRINT DATA = More_Date_Formats; RUN; /* Example 3. We can also extract the day, month, and year from a SAS date variable DAY(), MONTH(), YEAR() are three commonly used built-in SAS functions We also review the user-defined FORMAT. */ PROC FORMAT; /* Numeric format! */ VALUE WKDAYS 1 = &quot;Monday&quot; 2 = &quot;Tuesday&quot; 3 = &quot;Wednesday&quot; 4 = &quot;Thursday&quot; 5 = &quot;Friday&quot; 6 = &quot;Saturday&quot; 7 = &quot;Sunday&quot;; RUN; /* For character format, the syntax is */ PROC FORMAT; VALUE $ CHFRMT &quot;F&quot; = 1 &quot;M&quot; = 0; RUN; DATA SPLITTING_DATE; SET MDY_FUNCTION; DY = DAY(DOB); MNTH = MONTH(DOB); YR = YEAR(DOB); QUARTER = QTR(DOB); WKDAY = WEEKDAY(DOB); FRMT_WKDAY = WKDAY; FORMAT FRMT_WKDAY WKDAYS.; RUN; PROC PRINT DATA = SPLITTING_DATE; RUN; /** Example 4: Calculate the difference between two dates. The functions that can be used to calculate intervals include: 1. YRDIF(startdate, enddate, &#39;method&#39;) returns the difference in years between two SAS date values (startdate, enddate) using one of four methods (&#39;method&#39;) 2. DATDIF(startdate, enddate, &#39;method&#39;) returns the difference in days between two SAS date values (startdate, enddate) using one of four methods (&#39;method&#39;) 3. INTCK(&#39;interval&#39;, fromdate, todate) returns the number of time intervals (&#39;interval&#39;) that occur between two dates (fromdate, todate) 4. INTNX(&#39;interval&#39;, date, increment) applies multiples (increment) of a given interval (&#39;interval&#39;) to a date value (date) and returns the resulting value, and hence can be used to IDENTIFY past or future days, weeks, months, and so on. ---- PLEASE READ THE ABOVE DESCRIPTION CAREFULLY BEFORE YOU DO THE FOLLOWING EXAMPLE! **/ DATA DIET; LENGTH name $ 18; INFILE DATALINES DSD MISSOVER; INPUT subj 1-4 name $ 6-24 gender 25-26 height 28-29 weight 30-33 +1 wt_date1 mmddyy8. @43 wt_date2 mmddyy8. @52 b_date mmddyy8.; AGE_YRDIF = YRDIF(b_date, wt_date1, &#39;act/act&#39;); AGE_INTCK = INTCK(&#39;year&#39;, b_date, wt_date1); DAYS_DATDIF = DATDIF(wt_date1, wt_date2, &#39;act/act&#39;); DAYS_INTCK = INTCK(&#39;day&#39;, wt_date1, wt_date2); FORMAT wt_date1 wt_date2 b_date date9.; INT_AGE = ROUND(age_yrdif, 1); DATALINES; 1024 Alice Smith 1 65 125 12/1/05 03/04/06 01/01/60 1167 Maryann White 1 68 140 12/01/05 03/07/06 01/01/59 1168 Thomas Jones 2 . 190 12/2/05 3/30/06 06/15/60 1201 Benedictine Arnold 2 68 190 11/30/05 2/27/06 12/31/60 1302 Felicia Ho 1 63 115 1/1/06 4/1/06 06/15/58 ; RUN; PROC PRINT data=diet; TITLE &quot;The calculation of subject&#39;s age&quot;; *var subj b_date wt_date1 age_yrdif age_intck; RUN; /************************************************/ /** Topic #2. Automatic Variables **/ /************************************************/ /** Example 1 **/ DATA pets1; INPUT @1 name $9. @10 time time5. @20 date mmddyy8. @30 species $; /* New variables defined using automatic variables*/ MISTAKES = _ERROR_; /* Error indicator. */ OBS_SEQ = _N_; /* Observation sequence. */ DATALINES; Fluffy 9:00 02/13/98 cat Tom 10:00 02/13/98 cat Rex 13:00 02/31/98 dog Fido 14:00 02/13/98 dog Felix 9:30 02/13/98 cat Spot 15:00 02/13/98 dog ; RUN; PROC PRINT DATA = pets1; TITLE &quot;Automatic Variables: _N_ and _ERROR_&quot;; RUN; /** Example 2: FIRST.OBS and LAST.obs - most commonly used in longitudinal data sets **/ PROC SORT DATA = pets1; BY species time; RUN; DATA pets2; /* Make changes to dataset PETS1. */ SET pets1; BY species; pet_num = _n_ ; /* Pet number equal to observation number */ firstgrp = FIRST.species; /* firstgrp=1 if first obs of each species*/ lastgrp = LAST.species; /* lastgrp=1 if last obs of each species */ RUN; PROC PRINT DATA = pets2; * VAR pet_num name species time date mistakes firstgrp lastgrp; FORMAT time time5. date mmddyy8.; RUN; /*--------------------------------------------------------/ /* Example 3. A typical clinical trial data set ***/ /* We want to find the duration of individual patient ***/ /* from the first admission and the last discharge ***/ /*-------------------------------------------------------*/ DATA CLINICAL_TRIAL; INPUT @1 CPID 4. @5 CSTATE $2. @7 CHOSPID 3. @10 CGENDER $1. @11 CADMIT_D MMDDYY10. @21 CDISCH_D MMDDYY10. @31 CFIRST $1. @32 CMIDDLE $1. @33 CLAST $1. @34 CHXDIAB 1. @35 CDEATH 1. @36 C60DEATH 1. @37 C1YRDEATH 1. @38 CDOB MMDDYY10. @48 CTHERAPY 1.; FORMAT CADMIT_D MMDDYY10. CDISCH_D MMDDYY10. CDOB MMDDYY10.; DATALINES; 400101101M05/16/199605/29/1996U A101010/21/19460 400101101M05/16/199605/21/1996B P100107/08/19651 400101102F06/01/199606/02/1996J R100003/04/19651 400101102F08/15/199608/16/1996VSA100110/10/19561 400102201M07/02/199607/04/1996NIF010006/28/19460 400202202F06/20/199607/02/1996L I000009/06/19630 400202202M08/09/199608/11/1996QQN001007/13/19510 400203301F04/01/200204/02/2002I L110010/09/19080 400203301M07/12/199607/26/1996Q F101007/28/19600 401303302F02/06/199602/07/1996CKH100004/19/19640 401303302M06/03/199606/10/1996F N000108/09/19651 401303302M06/03/199606/10/1996F N000008/09/19651 401304401F05/15/199607/19/1996ZZA100012/23/19660 401304401F02/01/199502/10/1995IOV000101/01/19650 401304402F09/18/199609/19/1996TZP010006/18/19801 401404402F09/18/199609/19/1996TZP0.0106/18/19801 401404402M07/15/199607/24/1996MRT100003/04/19610 401405501F08/15/199608/22/1996CTL100004/05/19630 401405502M07/22/199608/05/1996M F010005/06/19680 402505502F09/11/199609/12/1996SIJ000006/07/19601 402505502F09/11/199609/12/1996SIJ000106/07/19600 402506601M11/18/199611/20/1996BGX100108/09/19820 402506601F03/15/199603/16/1996YJQ110009/09/19680 402606610M10/18/199610/19/1996MEZ100110/10/19311 402601102F06/01/199606/02/1996J R100003/04/19651 402602202F06/20/199607/02/1996L I000009/06/19630 402605502M07/22/199608/05/1996M F010005/06/19680 402606601M11/18/199611/20/1996RGX100108/09/19820 ; RUN; /** Sort by DOB before you use automatic variables first.var and last.var **/ PROC SORT DATA = CLINICAL_TRIAL; BY CPID CADMIT_D; /* sort ID first, then sort by date within each CPID */ RUN; /** We create two data sets: the first data set contains the information about the first visit of each patient, and the second data set has the information about the last visit. Then merge the two data sets and define the duration between the first and the last visits. **/ DATA FIRSADMIT LASTDISCH; SET CLINICAL_TRIAL; BY CPID; IF FIRST.CPID THEN OUTPUT FIRSADMIT; IF LAST.CPID THEN OUTPUT LASTDISCH; RUN; PROC PRINT DATA = FIRSADMIT; RUN; /* We match-merge the two data sets and keep the variables relevant to the calculation of the duration. Since Match-merging requires the BY statement, we sort the data sets by CPID and then merge the two data sets and keep only CPID and CADMIT_D in FIRSTVIS and CPID and CDISCH_D in the LASTVIS */ PROC SORT DATA = FIRSADMIT; BY CPID; RUN; PROC SORT DATA = LASTDISCH; BY CPID; RUN; /** Merging the two data sets **/ DATA FIRSTADMIT_LASTSICH; MERGE FIRSADMIT(KEEP = CPID CADMIT_D) /*only keep two variables */ LASTDISCH(KEEP = CPID CDISCH_D); /*only keep two variables */ BY CPID; DURATION = CDISCH_D - CADMIT_D; /* calculate the duration from the first admission the last discharge dates */ DUR_DATEDIF = DATDIF(CADMIT_D, CDISCH_D, &quot;act/act&quot;); /*using the date function to find the difference between the two dates */ RUN; TITLE &quot;Calculating the duration&quot;; PROC PRINT DATA = FIRSTADMIT_LASTSICH; RUN; TITLE &quot;&quot;; /**************************************************************/ /** Topic #3. Numerical Operators and Functions **/ /* Common Functions Example INT: the integer portion of a numeric value a = int(x); ABS: the absolute value of the argument a = abs(x); SQRT: the square root of the argument a = sqrt(x); MIN: the minimum value of the arguments a = min(x, y, z); MAX: the maximum value of the arguments a = max(x, y, z); SUM: the sum of the arguments a = sum(x, y, z); MEAN: the mean of the arguments a = mean(x, y, z); ROUND: round the argument to the specified unit a = round(x, 1); LOG: the log (base e) of the argument a = log(x); LAG: the value of the argument in the previous observation a = lag(x); DIF: the difference between the values of the argument in the current and previous observations a = dif(x); N: the number of non-missing values of the argument a = n(x); NMISS: the number of missing values of the argument a = nmiss(x); /***************************************************************************/ /** Example 1: Define new variables using numerical functions and operators **/ DATA GRADES; INPUT name $ 1-15 e1 e2 e3 e4 p1 f1; * calculate the average by definition; AVG1 = (e1+e2+e3+e4)/4; /* mathematical operations */ * calculate the average using the mean function; AVG2 = MEAN(e1,e2,e3,e4); /** MEAN is a SAS Mathematical function **/ DATALINES; Alexander Smith 78 82 86 69 97 80 John Simon 88 72 86 . 100 85 Patricia Jones 98 92 92 99 99 93 Jack Benedict 54 63 71 49 82 69 Rene Porter 100 62 88 74 98 92 ; RUN; PROC PRINT DATE = grades; TITLE &quot;New variables defined by functions and operations&quot;; VAR name e1 e2 e3 e4 avg1 avg2; RUN; /** Example 2: defining new variables using logical operators **/ DATA GRADES01; SET GRADES; IF (AVG2 &lt; 65) THEN status = &#39;Failed&#39;; ELSE status = &#39;Passed&#39;; RUN; PROC PRINT data = grades01; var name e1 e2 e3 e4 avg2 status; RUN; /***********************************************************************/ /** Topic #4. Data Type Conversion **/ /** **/ /** INPUT function converts character values to numeric values. **/ /** PUT function to convert your numeric values to character values **/ /***********************************************************************/ /** Example 1: explicit conversion using INPUT() and PUT() **/ DATA oscars; INPUT Title $ 1-20 ch_Year $ 23-26 Rating $ 29-32 Duration 35-37 num_gross 40-45; DATALINES; Slumdog Millionaire 2008 R 120 141.32 The Hurt Locker 2009 R 131 15.70 The King&#39;s Speech 2010 R 118 138.80 The Artist 2011 PG13 100 44.67 Argo 2012 R 120 136.02 12 Years a Slave 2013 R 134 56.67 Birdman 2014 R 119 42.34 Spotlight 2015 R 128 44.99 ; RUN; /** Checking variable types **/ PROC CONTENTS DATA = oscars; RUN; /** Variable conversion: numerical coding **/ DATA Variable_conversion; SET oscars; new_num_year = input(ch_year, 5.); /* ch -&gt; num */ new_ch_gross = put(num_gross, 8.2); /* num -&gt; ch */ RUN; PROC CONTENTS DATA = Variable_conversion; RUN; /**************************************************** Topic 5: Contains and Between-And operators in WHERE statement - subsetting ******************************************************/ /** Example 1 **/ DATA readin; INPUT name $ Section $ Score; DATALINES; Raj A 80 Atul A 77 Priya B 45 Sandeep A 95 Rahul C 84 Shreya C 44 Rahil C 87 Sahil B 49 ; RUN; DATA readin_Between; SET readin; WHERE Score BETWEEN 50 and 90; RUN; PROC PRINT DATA = readin_Between; RUN; /** Example 2: CONTAINS **/ DATA readin_contains; SET readin; WHERE name CONTAINS &#39;hil&#39;; RUN; PROC PRINT DATA = readin_contains; TITLE &quot;CONTAINS operator&quot;; RUN; /** Example 3: Like **/ /* WHERE NAME LIKE 慉___?; * 3 underscores (Selects all names of length 4, beginning with A) WHERE NAME LIKE 慉_%?; (Selects all names that begin with A and are at least two characters in length) */ DATA readin_Like02; SET readin; WHERE name LIKE &#39;_ah%&#39;; /* value contains string sh starting from the 2nd character! */ RUN; PROC PRINT DATA = readin_like02; TITLE &quot;LIKE operator&quot;; RUN; /** Example 4: Like **/ DATA readin_Like; SET readin; WHERE name LIKE &#39;Ra%&#39;; RUN; PROC PRINT DATA = readin_like; TITLE &quot;LIKE operator&quot;; RUN; /** Example 5: fuzzy testing - wildcard **/ DATA readin_wildcard; SET readin; WHERE name =* &#39;Ral&#39;; RUN; PROC PRINT DATA = readin_wildcard; TITLE &quot;LIKE operator&quot;; RUN; /************************************************** Real-world Application We want to calculate the duration of COVID-19 for EACH COUNTY in the US. The steps are given below: 1. Create a data set that contains the first covid case 2. Define a new variable DURATION = (09/27) - date of first record 3. we then use PROC MEANS to see the distribution of the duration. The dataset is on the course web page. We used this data set last week. You can download this data and save it in a local folder that SAS can access. ***************************************************/ /** import all relevant data sets **/ PROC IMPORT OUT= COVID_COUNTY DATAFILE= &quot;C:\\STA311\\w09\\w07-us-counties.csv&quot; DBMS=CSV REPLACE; GETNAMES=YES; DATAROW=2; RUN; /** Check the variable names and type **/ PROC CONTENTS DATA = COVID_COUNTY; RUN; /** Need to SORT the data by STATE, COUNTY, FIPS (one-to-one), DATE Caution: by the order!!!! **/ PROC SORT DATA = COVID_COUNTY; BY STATE COUNTY FIPS DATE; RUN; /** Extract the first record of each individual county and save it with name: COUNTY_FIRSTOBS **/ DATA COUNTY_FIRSTOBS; SET COVID_COUNTY; BY STATE COUNTY FIPS DATE; IF FIRST.county; /* only keep the first observation of each county!! */ DURATION01 = &quot;27SEP2020&quot;d - DATE; /* days since the first case to 9/27/2020 */ RUN; /** 5-number summary **/ PROC MEANS MIN Q1 Median Q3 MAX MAXDEC = 1 DATA = COUNTY_FIRSTOBS; CLASS STATE; VAR DURATION01; RUN; "],["string-functions-and-basic-loops.html", "Chapter 11 String Functions and Basic Loops 11.1 String Functions 11.2 Basic Loops 11.3 RETAIN Statement and Longitudinal Data Operations 11.4 Learning COding by Examples", " Chapter 11 String Functions and Basic Loops In this chapter, we continue to introduce more SAS functions and loops for efficient data manipulation. 11.1 String Functions SAS has a few convenient string functions that can be used to extract information from string variables or create new string variables. Strings in SAS are the values that are enclosed within a pair of single or double quotes. Also, the string variables are declared by adding a space and $ sign at the end of the variable declaration. SAS has many powerful functions to analyze and manipulate strings. We introduce some of these commonly used in string variable manipulation. For convenience, we will use PUT function to print out different manipulated strings in the log to see the values (results) of various string functions. For those string functions that deal with blank (white space) in the string function, we will enclose the outputs in asterisk (*). 11.1.1 Concatenation CAT, CATS, CATX, and || Concatenation is a common operation in manipulating string variables. There are several functions in SAS for this purpose. We use several examples to illustrate how to use these string functions. We first define a toy data set to be used in the examples. /*create dataset*/ DATA cats_example; INPUT firstName $ lastName $ points; DATALINES; Austin Smith 15 Brad Stevens 31 Chad Miller 22 Dave Michaelson 19 Eric Schmidt 29 Frank Wright 20 Greg Gunner 40 Harold Anderson 35 ; RUN; Concatenate Strings with Space in Between /*create new dataset with concatenated strings*/ DATA CAT_data01; set cats_example; fullName = CAT(firstName, lastName); PUT fullName; RUN; TITLE &quot;CAT function&quot;; PROC PRINT; /* no specified data set to print, The system will print out the most recently created data set*/ RUN; Concatenate Strings with No Space in Between /*create a new dataset with concatenated strings*/ DATA CATS_data; SET cats_example; fullName = CATS(firstName, lastName); PUT fullName; RUN; /*view new dataset*/ PROC PRINT; RUN; Concatenate Strings with Custom Delimiter /*create a new dataset with concatenated strings*/ DATA CATX_data; SET cats_example; fullName = CATX(&#39;-&#39;, firstName, lastName); PUT fullName; RUN; /*view new dataset*/ PROC PRINT; RUN; An Alternative of CATX(): || The double vertical bar (||) joins strings. It’s the oldest method in SAS to combine strings. /*create a new dataset with concatenated strings*/ DATA CATX_data02; SET cats_example; fullName = lastName|| &#39;,&#39;|| firstName; PUT fullName; RUN; /*view new dataset*/ PROC PRINT; RUN; Although || is an old concatenation operator, it is still convenient to use. We will use this to explain some string functions that involve blank spaces. 11.1.2 SUBSTR This function extracts a substring using the start and end positions. In case no end position is mentioned it extracts all the characters till the end of the string. Syntax SUBSTRN(&#39;stringval&#39;, p1, p2) /* stringval is the value of the string variable. p1 is the start position of extraction. p2 is the final position of extraction. */ Example DATA string_examples; LENGTH string1 $ 6 ; String1 = &#39;Hello&#39;; sub_string1 = SUBSTRN(String1, 2, 4) ; /*Extract from position 2 to 4 */ sub_string2 = SUBSTRN(String1, 3) ; /*Extract from position 3 onwards */ PUT x = string1; /* print this string in the log*/ PUT y = sub_string1; /* print this string in the log*/ PUT z = sub_string2; /* print this string in the log*/ RUN; The log file contains the resulting substring values. 11.1.3 String Function for Handling Blanks TRIM and TRIMN The TRIM function copies a character argument, removes trailing blanks, and returns the trimmed argument as a result. If the argument is blank, TRIM returns one blank. TRIM is useful for concatenating because concatenation does not remove trailing blanks. The TRIMN function copies a character argument, removes all trailing blanks, and returns the trimmed argument as a result. If the argument is blank, TRIMN returns a string with a length of zero. TRIMN is useful for concatenating because concatenation does not remove trailing blanks. The TRIMN and TRIM functions are similar. TRIMN returns a string with a length of zero for a blank string. TRIM returns one blank for a blank string. DATA trim_trimn; x = &quot;A&quot;||trim(&quot; &quot;)||&quot;B&quot;; y = &quot;A&quot;||trimn(&quot; &quot;)||&quot;B&quot;; z = &quot;A&quot;|| (&quot; &quot;)||&quot;B&quot;; PUT x; PUT y; PUT z; RUN; STRIP, LEFT, and RIGHT The STRIP function removes leading and trailing spaces. The LEFT function moves leading blanks to the end of the value. The length of the string does not change! The RIGHT function returns an argument with trailing blanks moved to the start of the value. The argument’s length does not change. Example DATA strip_example; name = &#39; Hitchy &#39;; char0 = &quot;*&quot;||Name||&quot;*&quot;; char1 = &quot;*&quot;||STRIP(Name)||&quot;*&quot;; char2 = &quot;*&quot;||LEFT(name)||&quot;*&quot;; char3 = &quot;*&quot;||RIGHT(name)||&quot;*&quot;; PUT char0; PUT char1; PUT char2; PUT char3; RUN; 11.1.4 COMPRESS vs COMPBL The COMPRESS function returns a character string with specified characters removed from the original string. The COMPRESS function allows null arguments. A null argument is treated as a string that has a length of zero. The COMPBL function removes multiple blanks in a character string by translating each occurrence of two or more consecutive blanks into a single blank. The COMPRESS function removes every occurrence of the specific character from a string. If we specify a blank as the character to remove from the source string, the COMPRESS function is similar to the COMPBL function. However, the COMPRESS function removes all blanks from the source string. The COMPBL function compresses multiple blanks to a single blank and has no effect on a single blank. Number of Arguments Results Only the first argument, source All blanks have been removed. If the argument is completely blank, then the result is a string with a length of zero. If you assign the result to a character variable with a fixed length, then the value of that variable will be padded with blanks to fill its defined length. Two arguments, source and chars All characters that appear in the second argument are removed from the result. Compressing Blanks DATA compress_example; a = &#39;*&#39;||&#39;AB C D &#39;||&#39;*&#39;; x = &#39;*&#39;||compress(a)||&#39;*&#39;; /* compress blanks */ y = &#39;*&#39;||compress(a,&#39;A &#39;)||&#39;*&#39;; /* compress `A` and blanks */ PUT a; PUT x; PUT y; RUN; Compressing Vowels DATA compress_example; str = &#39;123-4567-8901 e 234-5678-9012 i&#39;; a = &#39;*&#39;||str||&#39;*&#39;; x = &#39;*&#39;||compress(str)||&#39;*&#39;; /* compress blanks */ y = &#39;*&#39;||compress(str,&#39;ei &#39;)||&#39;*&#39;; /* compress `e`,`i` and blanks */ PUT a; PUT x; PUT y; RUN; COMPBL example DATA compblanks; string =&#39;125 E. Main St.&#39;; orig_str = &quot;*&quot;||string||&quot;*&quot;; street = &quot;*&quot;||compbl(string)||&quot;*&quot;; PUT orig_str; PUT street; RUN; 11.1.5 Change Character Case Functions Three SAS string functions can change character case: UPCASE LOWECASE, PROPCASE. UPCASE: returns the uppercase of the text LOWCASE: returns the lowercase of the text PROPCASE: returns the word having uppercase in the first letter and lowercase in the rest of the letter. DATA compblanks; string =&#39;125 E. Main St.&#39;; orig_str = &quot;*&quot;||string||&quot;*&quot;; str01 = &quot;*&quot;||LOWCASE(string)||&quot;*&quot;; str02 = &quot;*&quot;||UPCASE(string)||&quot;*&quot;; str03 = &quot;*&quot;||PROPCASE(string)||&quot;*&quot;; PUT orig_str; PUT str01; PUT str02; PUT str03; RUN; 11.1.6 Search Character Functions Searching characters in the string function is practically important. For example, if we want to extract dose information from vial labels, we need a search function to be jointly used with other string functions. There are several such string search functions in SAS: ANYALNUM, ANYALPHA, ANYDIGIT, ANYPUNCT, ANYSPACE, NOTALNUM, NOTALPHA, NOTDIGIT, NOTUPPER, FIND, FINDC, INDEX, INDEXC, INDEXW, VERIFY The names of the above search functions are self-explanatory. We will pick some of them to illustrate the use of this type of search function. the suffix NUM indicates numeric and ALPHA indicates character. Example STRING = &quot;ABC 123 ?xyz_n_&quot; More information about the SAS string function can be found in SAS documentation at https://support.sas.com/publishing/pubcat/chaps/59343.pdf 11.2 Basic Loops Iterative DO loops, DO UNTIL, and DO WHILE provide a wide variety of ways to perform repeated actions on your SAS data sets over and over again without having to write duplicate code or execute the same statements multiple times manually. 11.2.1 DO -loop Syntax DO index-variable=start TO stop BY increment; SAS statements END Example 1: Default increment 1 is used in the loop. DATA DOLoop; /* SAS dataset */ DO i = 1 to 5; /* I will be a variable in the SAS data set*/ Y = i**2; /* values are 1, 4, 9, 16, 25 , Y will be another variable in the data set.*/ OUTPUT; /* print out the value at the end of each iteration*/ END; RUN; Example 2: By default, each iteration of a DO statement increments the value of the counter by 1, but you can use the BY option to increment the counter by other amounts, including non-integer amounts. For example, each iteration of the following DATA step increments the value i by 0.5. DATA DOLoopBy; /* SAS dataset */ DO i = 1 to 5 BY 0.5; /* I will be a variable in the SAS data set*/ Y = i**2; /* values are 1, 1.5^2, 2^2 2.5^2,… Y will be another variable in the data set. */ OUTPUT; END; RUN; 11.2.2 DO-WHILE Loop By default, each iteration of a DO statement increments the value of the counter by 1, but you can use the BY option to increment the counter by other amounts, including non-integer amounts. For example, each iteration of the following DATA step increments the value i by 0.5: DATA DOLoopBy; /* SAS dataset */ DO i = 1 to 5 WHILE (y &lt; 20); /* i will be a variable in the SAS data set*/ Y = i**2; /* values are 1, 4, 9, 16, 25 , Y will be another variable in the data set. */ OUTPUT; END; RUN; 11.2.3 DO-UNTIL Loop Using a DO UNTIL loop, SAS executes the DO loop until the expression you’ve specified is true. DATA investment; value = 0; year = 0; DO UNTIL (value &gt;= 5000); value + 1200; /* 1st update */ value + value * 0.05; /* 2nd update */ year + 1; /* update of year */ OUTPUT; END; RUN; 11.3 RETAIN Statement and Longitudinal Data Operations The RETAIN statement simply copies retaining values by telling the SAS not to reset the variables to missing at the beginning of each iteration of the DATA step. If the RETAIN statement is NOT used, SAS will return a missing value at the beginning of each iteration. Next, we use an example to explain how RETAIN statement works. DATA base; INPUT id $ sales vis_date mmddyy10.; DATALINES; a 235 07/11/1997 a 324 11/12/1997 b 321 06/15/1998 b 319 09/21/1998 b 357 11/11/1998 c 279 07/21/1997 c 302 10/20/1997 c 314 11/19/1997 c 298 12/27/1997 ; RUN; Data Manipulation Task Count the number of sales per person Calculate the total sales per person Calculate average sales per person The original data set is a longitudinal data set (i.e., each subject has multiple records taken over time). We need to work with the observation within groups. DATA new; SET base; BY id; RETAIN count total; /* retain the value during the DO-loop until the last record of each subject. */ IF FIRST.id THEN DO; /*initialization at first record of each subject*/ count = 0; /* set count to 0 for each subject */ total = 0; /* set total to 0 for each subject */ END; count = count + 1; /* accumulative calculation */ total = total + sales; /* accumulative calculation */ IF LAST.id THEN DO; /* find the last record of each subject */ mean = total / count; /* Calculate the mean for each subject */ Total_sale = total; /* Total sales */ Total_sale_count = count; /* Number of sales */ OUTPUT; /* print to the SAS data set: new */ END; TITLE &quot;Average Sales&quot;; PROC PRINT DATA=new; RUN; 11.4 Learning COding by Examples This section provides additional examples for practicing SAS string functions, loops, and related functions for effective and efficient data manipulation. Some of the string functions in the examples were not discussed in the previous sections. They are equally important as those covered in the previous sections. /****************************************************************************** Topics: SAS Character Functions 1. Leading zeros and Blanks: INDEXC, SUBSTR, LENGTH, and LEFT 2. Substring Substitution: TRANSLATE 3. Handling Blanks: COMPRESS, COMPBL, TRIM 4: Concatenation: CATs family of functions SAS DO-Block 1. DO-loop 2. DO-UNTIL loop 3. DO-WHILE loop RETAIN Statement 1. RETAIN statement 2. Within Group Operation in Longitudinal Data *****************************************************************************/ * OPTIONS PS= 74 LS = 74 NODATE NONUMBER; /*NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN*/ /*************************************************/ /** SAS Character Functions ****/ /*************************************************/ /*NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN*/ LIBNAME week10 &quot;&quot;; DM &#39;CLEAR OUT&#39;; DM &#39;CLEAR LOG&#39;; /* 1. Leading zeros: INDEXC and SUBSTR */ /** Example 1 **/ DATA ZIP_CODE; INPUT ID $ 1-7 NAME $ 9-22 COUNTY $ 24-30 STATE $ 31-32 ZIP $ 34 - 44 ER $ 46; DATALINES; A01101 Smith, Jean Orange NC 27515-2688 Y A99126 Moore, Ronald Wake NC 27511-2414 N B031073 Adams, Beth Wake NC 27705-2102 N B001324 Polinski, Gus Durham NC 27606-4010 Y ; RUN; /* Extract the 5 digit zip code */ DATA Five_digit_ZIP; SET ZIP_CODE; ZIP5 = SUBSTR(ZIP, 1, 5); KEEP NAME COUNTY ZIP ZIP5; RUN; PROC PRINT; RUN; /** Example 2: leading zeros **/ DATA LEADING_0; INPUT NUMBER $; NON_0 = INDEXC(NUMBER, &quot;123456789&quot;); /* given the index of the first digit in any of the digits in the second argument */ NEW_NUMBER = SUBSTR(NUMBER, NON_0); /* extract a substring starting from the index (physical location) to the end of the string */ DATALINES; 0123 117_0K 00033Y ; RUN; PROC PRINT DATA = LEADING_0; RUN; /* 2. LENGTH and SCAN LENGTH returns the length of the value of the string; SCAN returns the nth word in a character string. By default, positive n from left to right; negative n, from right to left. */ DATA CITY_STATE; LENGTH CITY_STATE $ 30; INPUT CITY_STATE &amp; $; /* attention: &amp;(ampersand) modifier */ /* &amp; tells SAS that words separated by a *SINGLE* blank define a value of a character variable. */ DATALINES; King and Queen Court House VA Saint Mary of the Woods IN West Palm Beach FL Outer Banks NC ; RUN; PROC PRINT; RUN; DATA SEP_SITY_STATE; SET CITY_STATE; LEN = LENGTH(CITY_STATE); STATE = SCAN(CITY_STATE, -1); /* -1 =&gt; last word */ CITY = SUBSTR(CITY_STATE, 1, LEN-3); /* 1=starting character, -3 = blank space + 2 state abbreviation */ RUN; PROC PRINT DATA = SEP_SITY_STATE; RUN; /**************************************************************************** 3. Functions for Handling Blanks TRIM()--&gt; removes the trailing blanks. however, if there are blank, TRIM returns only one blank in case of multiple consecutive blanks. TRIMN()--&gt; returns no blank in case of a blank string. STRIP() --&gt; removes both leading and trailing blanks COMPRESS()--&gt; removes all blanks COMPBL() --&gt; compresses multiple blanks into a single blank. *****************************************************************************/ DATA WHITE_SPACES; INPUT str_name $char14.; DATALINES; Mary Smith /* contains trailing blanks */ John Brown /* contains leading blanks */ Alice Park /* contains leading and trailing blanks */ Tom Wang /* contains leading, trailing, and multiple blanks in between */ /* contains a blank string */ ; RUN; PROC PRINT; RUN; DATA HANDLING_BLANKS; SET WHITE_SPACES; raw_str_name = &#39;*&#39;||str_name||&#39;*&#39;; /* simple concatenation: we can see the blanks in the original str_name.*/ strip = &#39;*&#39;||STRIP(str_name)||&#39;*&#39;; /* remove both leading and trailing blanks*/ trim_left = &#39;*&#39;||TRIM(LEFT(str_name))|| &#39;*&#39;; /* TRIM removes the trailing blanks; LEFT aligns the string to the left. Use the LEFT function and the TRIM function together, we can first remove leading blanks and then remove trailing blanks, which will return the same results as the STRIP function. */ trimn_left = &#39;*&#39;||TRIMN(LEFT(str_name))||&#39;*&#39;; /* TRIMN returns no blank for a blank string. */ compressed_name = COMPRESS(raw_str_name); /* COMPRESS removes all the blanks from the string.*/ comp_BL = COMPBL(raw_str_name); /* COMPBL removes multiple blanks compressed into original single blank*/ RUN; PROC PRINT DATA = HANDLING_BLANKS; RUN; /********************************************************************* 4 Concatenate Strings and Handle Blanks: Play with CATs CAT() function concatenates character strings without removing leading or trailing blanks. CATT() function concatenates character strings and removes trailing blanks. CATS() function concatenates character strings and removes leading and trailing blanks. CATX() function concatenates character strings, removes leading and trailing blanks, and insert separators between each string. *********************************************************************/ /** Concatenating strings: || and CAT Sometimes we may want to concatenate two or more strings in managing string variables. CAT() has several variants **/ DATA CATS_FUN; SET WHITE_SPACES; LENGTH cat_str catt_str cats_str $16 catx_str $20; text=&#39;Hello&#39;; /** new variables by concatenating strings **/ cat_str = cat (&#39;*&#39;,str_name,&#39;*&#39;); /* equivalent to: || --&gt; simple concatenating of two strings */ catt_str = catt(&#39;*&#39;,str_name,&#39;*&#39;); /* equivalent to: TRIM || or TRIMN ||; --&gt; removes only trailing blanks */ cats_str = cats(&#39;*&#39;,str_name,&#39;*&#39;); /* equivalent to: STRIP ||; --&gt; removes leading and trailing blanks */ catx_str = catx(&#39;!&#39;,text,str_name); /* equivalent to: STRIP || separator; removes leading and trailing and insert separators in between strings */ RUN; PROC PRINT DATA = CATS_FUN; RUN; DATA Concatenation0; INFILE DATALINES MISSOVER; /* missing values at the end of the record */ LENGTH first last $20; INPUT first $ last $ ; DATALINES; jone smith john wayne bill phil hodge ; RUN; /** CAUTION: There are some white spaces in the original names due to the specification of the length. You cannot see this white space in the HTML output, but you can see these blanks in the list out the window. *********** ASSUMING X1, X2, X3, and X4 are four strings ******** LEFT(X1) -&gt; left aligns a character and removes leading blanks. CAT(of X1-X4)== X1||X2||X3||X4 --&gt; simply combines strings CATS(of X1-X4)==TRIM(LEFT(X1))||...||TRIM(LEFT(X4)) --&gt; removes leading and trailing blanks CATT(of X1-X4)== TRIM(X1)||TRIM(X2)||TRIM(X3)||TRIM(X4) --&gt; removes only trailing blanks CATX(of X1-X4)== TRIM(LEFT(X1))||SP||...||SP||TRIM(LEFT(X4)) --&gt; removes leading and trailing SP = separator and insert separators in between strings **/ /* check the output in the list output window! */ DATA Concatenation1; SET Concatenation0; NAME = catx(&quot;, &quot;, of last first ); /* removes leading and trailing and add a separator in between strings */ NAME_CAT = cat(of last first); /* simple concatenating (with blanks in between) strings */ NAME_CATS = cats(of last first); /* concatenating (with no blanks) and then removing leading and trailing blanks*/ NAME_CATT = catt(of last first); /* concatenating (with no blanks) and then removing the trailing blanks*/ /* Testing a few other */ CATS_NAME_CAT = CATS(NAME_CAT); /* removes the trailing and leading (In this particular example, no leading and railing blanks found in Name_CAT variable!) */ CATTS_NAME_CAT = CATT(NAME_CAT); RUN; PROC CONTENTS DATA = Concatenation1; RUN; PROC PRINT; RUN; /* 6. TRANSLATE =&gt; converts characters that are similar digits to actual digits: for example, Oo -&gt; 00 LI -&gt; 11 */ DATA STREET; INPUT ID $ 1-7 STREET_ADRR $ 9- 30; DATALINES; A01101 4 Conner St. A99126 13O Market St. B031073 442I Glenwood Ave. B001324 18o Cannon Dr. A03121 10L Cannon Dr. B991401 2IO Ear Ave. A021313 3O1 Luck Dr. ; RUN; /* The following dataset corrects the error to convert to actual digits and then use a concatenating function to make a correct address concatenating function and operator: || ==&gt; concatenates two strings */ DATA DIGIT_CORRECTION; SET STREET; DIGIT = SCAN(STREET_ADRR, 1); /* extract the first word of the string */ NEW = TRANSLATE(DIGIT, &quot;00111&quot;, &quot;OoLIl&quot;); /* corrected digits */ RUN; PROC PRINT; RUN; /*NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN*/ /*************************************************/ /** SAS Loops ****/ /*************************************************/ /*NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN*/ /** 1. DO-loop **/ DATA DOLoop; /* SAS dataset */ DO i = 1 TO 5; /* I will be a variable in the SAS data set */ Y = i**2; /* values are 1, 4, 9, 16, 25 , Y will be another variable in the data set. */ OUTPUT; /* OUTPUT ==&gt; writes every record to the SAS data set. Only the value in the last iteration will be written to the SAS data set if OUTPUT was not used. */ END; RUN; PROC PRINT; RUN; DATA DOLoopBy; /* SAS dataset */ DO i = 1 TO 5 BY 0.5; /* I will be a variable in the SAS data set*/ Y = i**2; /* values are 1, 4, 9, 16, 25 , Y will be another variable in the data set. */ OUTPUT; /* Write the value generated in each iteration to the SAS data set */ END; RUN; PROC PRINT; RUN; /** FOR-each: LAG() function **/ DATA FOR_EACH; DO V = 1, 1, 2, 3, 5, 8, 13, 21; /* DO-loop enumerate all values */ lag_V = lag(V); /* LAG function: drop the last value and a missing as the initial value */ Y = V/lag(V); OUTPUT; /* Write the value generated in each iteration to the SAS data set */ END; RUN; PROC PRINT; RUN; /** 2. DO-WHILE: WHILE clause to iterate as long as a certain condition holds**/ DATA DO_WHILTW_Loop; /* SAS dataset */ DO i = 1 to 6 WHILE (y &lt; 20); /* I will be a variable in the SAS data set*/ Y = i**2; /* values are 1, 4, 9, 16, 25 , Y will be another variable in the data set. */ OUTPUT; END; RUN; PROC PRINT; RUN; /** 3. DO-UNTIL: UNTIL clause to iterate as long as a certain condition holds **/ DATA investment; DO UNTIL (value &gt;= 50000); /* looping until value &gt;= 50000 */ value + 1200; /* initial value = 0, after this statement, value = 1200 */ value + value * 0.05; /* The result: 1200 + 1200*0.05 = 12600 */ year + 1; /* The result: 0 + 1 = 1 */ OUTPUT; /* write the value generated in each individual iteration. */ END; /* closing the loop: stopping rule meets */ RUN; PROC PRINT; RUN; /** 4. Nested loop **/ DATA design; DO i = 10 to 40 by 10; DO j = 3 to 15 BY 3; OUTPUT; END; END; RUN; PROC PRINT DATA = design; RUN; /** 4. Single loop application: The following example uses DO-loop to define a new variable with updated values in each iteration. You define the raw dataset first and then add the new variable with updates using the DO loop. **/ /* Example 1: DO-loop in a DATA step with INPUT-DATALINES statements */ DATA CD_INVEST (DROP = i); /* i is only used in loop statements, drop this meaningless variable and keep the data clean. */ INPUT Type $ 1-7 AnnualRate Months; /* data modification starts here */ Investment = 5000; /* add a new variable to the data with an initial value */ DO i = 1 TO Months; /* DO loop to update the value of INVESTMENT in each iteration */ Investment + (AnnualRate/12)*Investment; /* updating INVESTMENT */ * OUTPUT; /* OUTPUT should NOT be used here, otherwise, It will generate MONTHLY amounts!!! */ END; FORMAT Investment dollar8.2; /* formatting INVESTMENT to have a nice formatted display */ DATALINES; 03Month 0.01980 3 06Month 0.02230 6 09Month 0.02230 9 12Month 0.02470 12 18Month 0.02470 18 24Month 0.02570 24 36Month 0.02720 36 48Month 0.02960 48 60Month 0.03445 60 ; RUN; PROC PRINT DATA = CD_INVEST; RUN; /** Example 2: two data steps to create the same data set **/ /* Step 1: create a data set*/ DATA CD_INVEST_RAW; INPUT Type $ 1-7 AnnualRate Months; DATALINES; 03Month 0.01980 3 06Month 0.02230 6 09Month 0.02230 9 12Month 0.02470 12 18Month 0.02470 18 24Month 0.02570 24 36Month 0.02720 36 48Month 0.02960 48 60Month 0.03445 60 ; RUN; /* Step 2: Add new variable */ DATA CD_INVEST_GAIN; SET CD_INVEST_RAW; /* data modification starts here */ Investment = 5000; /* add a new variable to the data with an initial value */ DO i = 1 TO Months; /* DO loop to update the value of INVESTMENT in each iteration */ Investment + (AnnualRate/12)*Investment; /* updating INVESTMENT*/ OUTPUT; END; FORMAT Investment dollar8.2; /* formatting INVESTMENT to have a nice formatted display */ DROP I; RUN; PROC PRINT DATA = CD_INVEST_GAIN; RUN; /*NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN /*********************************************************** Working with Groups within Longitudinal Data Sets: RETAIN and DO-loop Task: (1). the cumulative sum of the total score of each subject. (2). Count the number of records of each subject (3). Cumulative average of each subject. *********************************************************** NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN*/ /** Typical longitudinal data **/ DATA BASE; INPUT ID $ SALES VIS_DATE mmddyy10.; DATALINES; a 235 07/11/1997 a 304 11/12/1997 b 321 06/15/1998 b 319 09/21/1998 b 357 11/11/1998 c 279 07/21/1997 c 302 10/20/1997 c 314 11/19/1997 c 298 12/27/1997 ; RUN; /* sort by ID and Date, */ PROC SORT DATA = BASE; BY ID VIS_DATE; RUN; /** With NO RETAIN: 1. New variables that are in the original data will be initialized as missing values in each iteration. 2. Any arithmetic operation that involves a missing value will result in a missing value. **/ DATA NEW_NO_RETAIN; SET BASE; BY ID; IF FIRST.id THEN DO; /* initialize the variables */ count = 0; total = 0; END; /* 1st iteration */ /* 2nd iteration */ count = count + 1; /* count = 0 + 1 = 1 */ /* count = * + 1 = * */ total = total + sales; /* total = 0 + 235 = 235 */ /* total = * + 304 = * */ avg = total/count; /* avg = 235/1 = 235 */ /* avg = */* = * */; OUTPUT; /* write out records in each iteration */ RUN; PROC PRINT DATA = NEW_NO_RETAIN; RUN; /** With RETAIN: 1. RETAIN will retain the value from the previous iteration. 2. New variables will not be initialized as missing values since the retained value from the previous iteration will be used. **/ DATA NEW_RETAIN; SET BASE; BY ID; RETAIN count total; /* retain the value in the current iteration to the next iteration */ IF FIRST.id THEN DO; /* initialize the variables */ count = 0; total = 0; END; /* 1st iteration */ /* 2nd iteration */ count = count + 1; /* count = 0 + 1 = 1 */ /* count = 1 + 1 = 2 */ total = total + sales; /* total = 0 + 235 = 235 */ /* total = 235+304 = 539 */ avg = total/count; /* avg = 235/1 = 235 */ /* avg = 539/2 = 269.5 */; OUTPUT; /* Write out the new records in each iteration. */ RUN; PROC PRINT DATA = NEW_RETAIN; RUN; /******************************************************/ /** Only output the last observation of each subject**/ /******************************************************/ DATA NEW_RETAIN_LAST_OBS; SET BASE; BY ID; RETAIN count total; /* retain the value in the current iteration to the next iteration */ IF FIRST.id THEN DO; /* initialize the variables */ count = 0; total = 0; END; count = count + 1; /* count on the right hand is 0 */ total = total + sales; /* total on the right hand is a missing value */ avg = total/count; IF LAST.id THEN DO; avg = avg*1; OUTPUT; /* Write out the average when reading the last record of each subject */ END; RUN; PROC PRINT DATA = NEW_RETAIN_LAST_OBS; RUN; "],["sas-arrays.html", "Chapter 12 SAS Arrays 12.1 Array Syntax 12.2 Methods of Specifying ARRAY Elements 12.3 Use of Array 12.4 Reshape Data 12.5 Learning Coding by Examples", " Chapter 12 SAS Arrays In SAS, arrays are used for retrieving and storing a set of values based on an index value. The index denotes the reserved location for storing the particular value in the cell. In a SAS DATA phase, arrays provide an acceptable and simple technique to process a set of variables. 12.1 Array Syntax The syntax of the array is given by ARRAY array-name {n} &lt;$&gt; &lt;length&gt; &lt;array-elements&gt; &lt;initial-values&gt;; The ARRAY statement creates an array in SAS. This statement starts with the ARRAY keyword, followed by the ARRAY name, the ARRAY length, and some optional ARRAY parameters. The ARRAY Name must be a valid SAS name. That is to say, it has a maximum length of 32 characters and starts with a letter or an underscore. Subsequent characters must be alphanumeric characters. An array name can’t contain blanks or special characters (except underscores). In addition, it can’t have the same name as any variable on the dataset. Also, although possible, you should not give your array the same name as an existing SAS function. The ARRAY Length, a mandatory component of ARRAR, specifies the number of elements in the array and must be enclosed in braces, brackets, or parenthesis. We can use the asterisk (*) to let SAS determine the number of elements. In this case, we might even omit the specification of the array elements. The ARRAY Type specifies whether the array is a character or a numeric array. By default, the elements of an array are numeric. We can create a character array in SAS by placing the dollar sign ($) after the length of the array. The Elements Length - length of variables to store in an array. All elements in a SAS array have a default length of 8 bytes. For an array with numeric elements, this is enough. For an array with a character element of 8 bytes can only store information of at most 8 characters. If needed, we can specify the length of character elements. The Array Elements can be existing variables or new variables. All elements must have the same type, either numeric or character. If the elements of the array are existing variables, then the array automatically inherits the type and length of the variables. If the elements of the array are new variables, SAS creates a numeric array with elements of length 8. The Initial Values can be either numeric or character. Character strings must be enclosed in quotation marks. The list of initial values must be written between parenthesis, and the values can be separated by a blank or a comma. Example: ARRAY names {3} $ first_name middle_name last_name (&quot;Eric&quot;, &quot;Arthur&quot;, &quot;BLAIR&quot;); ARRAY - Keyword. names - the name of the array. {3} - the length of the array. **\\(** - the array type: `\\)` indicates a character array. first_name middle_name last_name - three elements in the array. (“Eric”, “Arthur”, “BLAIR”) - initial values of the array. 12.2 Methods of Specifying ARRAY Elements Depending on the situation, several different ways can be used to specify array elements. 12.2.1 Explicit Definition If there are a smaller number of array elements to store in an array, we can define the names of the elements explicitly. In the above example, three variables first_name, middle_name, last_name are explicitly defined and listed. 12.2.2 Specify A Range of Elements This is very common in practical applications in which we may have a large number of array elements (variables). To use this method, we need to name the element in a pattern so that we can define a range of the elements. For example, consider surveying undergraduates’ starting salaries at 50 universities. We randomly select 100 recently graduated students and record their salaries in variables Univ1, Univ2, Univ3, ….., Univ50. Then we can define an array and specify the array element in the following way. ARRAY SalarySurvey {50} Univ1 - Univ50; With a single hyphen (-), we select (for existing variables) or create (for new variables) a range of elements. Note that, the length of the array is not necessarily specified, we can also use an asterisk (*) or simply omit the length specification since it is not mandatory in the array definition. That is, the following two array definitions are valid. ARRAY SalarySurvey {*} Univ1 - Univ50; ARRAY SalarySurvey Univ1 - Univ50; 12.2.3 Select All Variables Between A Start and End Variable With a double hyphen (–-) we can select a range of existing variables to form the elements of an array. If we use this method, SAS will create elements of all variables between the first and last variables. Note: A double dash (--) is used to specify variables based on the order of the variables as they appear in the file, regardless of the name of the variables. To explain this, we use an SAS built-in data set in SASHELP library. DATA cars; SET sashelp.cars; RUN; PROC CONTENTS DATA = cars VARNUM; /* Print out variable in creation order */ RUN; For example, here we use a double hyphen to create a numeric array of all variables between the EngineSize and Weight variables of the CARS dataset in the SASHELP library. DATA array_test; SET sashelp.cars; ARRAY height_array {*} EngineSize--Weight; /* range is based on the vraiable (creation) order in the data set.*/ array_size = DIM(height_array); /* This return ARRAY size*/ RUN; 12.2.4 Using Automatic Variable There is an efficient way to create an array of all existing numeric or character variables. With the _NUMERIC_ keyword, you can declare an array where all the numeric variables are used as elements. Like, you can use the _CHARACTER_ keyword to select all character variables as the array elements. If you use one of these keywords, it isn’t necessary to define the type and length of the array. DATA Num_array; SET sashelp.cars; ARRAY num_array {*} _numeric_; /* array to store all numeric variables */ numarray_dim = DIM(num_array); /* length of array */ RUN; 12.2.5 SAS Created Elements If we don’t specify the elements of the array with one of the methods mentioned above, SAS creates elements based on the array name. In this case, it is necessary to define the length of the array. For example, with the ARRAY statement below, we create an array of length 6 where the elements are called height1, height2, …, height6. DATA SAS_Auto_Def; ARRAY height {6}; RUN; 12.3 Use of Array SAS arrays are extremely useful to create new variables and carry out repetitive operations. An array is usually used jointly with loops and related SAS functions. In this section, we will use various examples to demonstrate the various applications using SAS arrays. 12.3.1 Referencing Elements of an Array If we work with arrays in SAS, we need to know how to reference their elements. You access an element in an array based on its position (or index) in the array. Unlike many other programming languages, SAS starts array index variables with the value of “1”. (Many other languages such as Python start with “0”.) To reference an element of an array, we need the array name followed by the element’s position between braces. Example DATA city; ARRAY city_array {*} $ 20 city1-city3 (&quot;Paris&quot;, &quot;Rome&quot;, &quot;Amsterdam&quot;); PUT &quot;The 2nd city is: &quot; city_array{2}; RUN; 12.3.2 Array Operators We can use the elements of an array to carry out arithmetic operations and as arguments for numeric and character functions. Hence, you could sum, multiply, concatenate, etc. the elements of an array. However, two operators are especially powerful when we work with arrays, namely the IN operator and the OF operator. Here we discuss what they do and how to use them. IN Operator The IN operator checks if a given value is equal to the value of one of the elements of an array. You can use this operator for numeric and character values. For example, here we check if the city_array contains the value Madrid. We create a new column check_Madrid with the answer. DATA IN_operator; ARRAY city_array {*} $ 20 city1-city3 (&quot;Paris&quot;, &quot;Rome&quot;, &quot;Amsterdam&quot;); IF &quot;Madrid&quot; IN city_array THEN check_Madrid = &quot;Yes&quot;; ELSE check_Madrid = &quot;No&quot;; RUN; PROC PRINT DATA = IN_operator NOOBS; /* suppress obs ID numbers */ RUN; OF Operator We can use the OF operator when we carry out arithmetic operations. With the OF operator, SAS takes all elements of the array into account while performing the calculation. You place the OF operator within the arithmetic function followed by the array name and an asterisk between parenthesis. DATA students; INFILE DATALINES DLM = &quot;,&quot;; INPUT student_name $ student_id physics biology geography; DATALINES; Mike, 1, 70, 65, 82 Maria, 2, 88, 75, 79 Alex, 3, 64, 72, 80 ; RUN; PROC PRINT DATA = students NOOBS; /* suppress obs ID numbers */ RUN; DATA scores; SET students; /* define an array*/ ARRAY scores_array {*} physics--geography; /* summary statistics with array */ avg_score = MEAN(OF scores_array(*)); /* asterisk (*) mean all values in the array. */ max_score = MAX(OF scores_array(*)); RUN; PROC PRINT DATA = scores NOOBS; RUN; 12.3.3 ARRAY with Loops If we have to perform a repetitive task, we can combine the power of the SAS array and a DO loop to make our code more efficient. Instead of writing one line of code for each variable, we can create an array of the variables we want to modify. Then, we use the DO loop to efficiently iterate over each element of the array and carry out the desired operation. Example We want to convert all character variables to all upper case. A brutal force approach is to do the conversion one by one (repetitive task). We can use a loop with an array to perform the conversion in a single loop. Let’s convert all character variables to upper case. PROC PRINT DATA = sashelp.cars (obs=10) NOOBS; RUN; The first five variables are character variables. We next define a character array to store all five character variables and then use a loop to convert these character variables to the upper case. DATA cars_char_upcase; SET sashelp.cars; /* define an array to store all character variables */ ARRAY char_array {*} _CHARACTER_; DO i = 1 TO DIM(char_array); /* Note: DIM(char_array) = 5 */ char_array(i) = UPCASE(char_array(i)); /* each iteration converts one */ END; RUN; TITLE &quot;Upper Case Conversion&quot;; PROC PRINT DATA = cars_char_upcase (OBS=10) NOOBS; RUN; 12.4 Reshape Data It is common to reshape a data set in various data analyses. Consider the following data task. The annotated code is given by 12.5 Learning Coding by Examples This section provides more examples for practicing array operations and related procedures that are not discussed in the previous sections. /******************************************** Topics: 1. Review of Do Block &amp; DO Loops 2. Concepts of SAS Arrays 3. PROC TRANSPOSE 4. Temporary Arrays 5. Restructuring Tables *********************************************/ OPTIONS PS = 65 LS = 78 NONUMBER NODATE; /** Topic 1. More examples of DO-Loop We have done examples of DO-block, DO-WHILE, and DO-UNTIL. The following is an example of a DO block that uses the explicit list of numeric or character values. */ * Example 1; DATA SALES; INPUT units_sold warranty $ Laptopmodel $; DATALINES; 21 1 AT3810 34 0 AT3600 12 1 AT3600 11 0 AT3810 ; RUN; DATA revenue; SET sales; IF Laptopmodel= &quot;AT3600&quot; THEN DO; IF warranty = 1 THEN revenue = units_sold*(1199.99 + 39); IF warranty = 0 THEN revenue = units_sold*1199.99; END; RUN; PROC PRINT DATA = revenue; RUN; * Example 2; DATA DECK; FORMAT value $5. suit $8.; DO value=&#39;ace&#39;,&#39;2&#39;,&#39;3&#39;,&#39;4&#39;,&#39;5&#39;,&#39;6&#39;,&#39;7&#39;,&#39;8&#39;,&#39;9&#39;, &#39;10&#39;,&#39;jack&#39;,&#39;queen&#39;,&#39;king&#39;; DO suit=&#39;spades&#39;,&#39;hearts&#39;,&#39;clubs&#39;,&#39;diamonds&#39;; OUTPUT; END; END; RUN; PROC PRINT DATA = DECK; RUN; /********************************************************** Topic 2: SAS ARRAY: Basics and Structure *********************************************************** An array is a temporary holding site for a collection of variables upon which the same operations will be performed. It is often difficult to find DO loops to be used jointly with ARRAY manipulation. **/ /** Working SAS data set: family income **/ DATA faminc; INPUT famid faminc1-faminc12 ; /* short cut of patterned variable names */ DATALINES; 1 3281 3413 3114 2500 2700 3500 3114 3319 3514 1282 2434 2818 2 4042 3084 3108 3150 3800 3100 1531 2914 3819 4124 4274 4471 3 6015 6123 6113 6100 6100 6200 6186 6132 3123 4231 6039 6215 ; RUN; /** Task: replacing each income &lt; 3000 with a miss value. An inefficient approach - intuitive and understandable. **/ DATA recode_manual; SET faminc; IF faminc1 &lt; 3000 THEN faminc1=.; IF faminc2 &lt; 3000 THEN faminc2=.; IF faminc3 &lt; 3000 THEN faminc3=.; IF faminc4 &lt; 3000 THEN faminc4=.; IF faminc5 &lt; 3000 THEN faminc5=.; IF faminc6 &lt; 3000 THEN faminc6=.; IF faminc7 &lt; 3000 THEN faminc7=.; IF faminc8 &lt; 3000 THEN faminc8=.; IF faminc9 &lt; 3000 THEN faminc9=.; IF faminc10 &lt; 3000 THEN faminc10=.; IF faminc11 &lt; 3000 THEN faminc11=.; IF faminc12 &lt; 3000 THEN faminc12=.; RUN; /* NOTE: heading option specifies horizontal (H) column headings */ PROC PRINT DATA = recode_manual NOOBS HEADING = H; TITLE &quot;Processing with a regular data step&quot;; RUN; /* What if you 1000 variables in a dataset, it is inefficient, if not infeasible, to use the above data step to process the replacement in the data set. SAS array can be used to simplify the process! */ DATA recode_array; SET faminc; ARRAY Afaminc[12] faminc1-faminc12; DO i = 1 TO 12; /* loop index */ IF Afaminc[i] &lt; 3000 THEN Afaminc[i] = . ; END; DROP i; RUN; PROC PRINT DATA = recode_array NOOBS HEADING = H; TITLE &quot;Processing with an ARRAY in a data step&quot;; RUN; /************************************************************ Topic 3. Types of Automatic ARRAYS *************************************************************; /* Working Data Set */ DATA Sample_data; INPUT x1 x2 x3 x4 $ x5 $; DATALINES; 1 2 3 AA BB 2 3 4 AB CC 3 4 5 AC DD 4 5 6 AD EE 5 6 7 AE FF 6 7 8 AF GG ; RUN; /* Example 1. automatic numeric ARRAYs */ DATA NUM_ARRAY; SET Sample_data; * ARRAY NUMARRAY[*] x1-x3; /* explicit list of variables */ ARRAY NUMARRAY[*] _NUMERIC_; /* implicit list of all numeric variables */ DO i = 1 TO DIM(NUMARRAY); IF NUMARRAY[i] &gt; 3 THEN NUMARRAY[i] =.; END; DIMARRAY = DIM(NUMARRAY); DROP I; RUN; PROC PRINT DATA = NUM_ARRAY; RUN; /* Example 2. automatic character ARRAYs */ DATA CHAR_ARRAY; SET Sample_data; ARRAY CHARARRAY[*] _CHARACTER_; /* implicit of character variables */ DO i = 1 TO dim(CHARARRAY); CHARARRAY[i] = SUBSTR(CHARARRAY[i],1,1); /* extract the 1st character */ END; DROP i; RUN; PROC PRINT DATA = CHAR_ARRAY; RUN; /** Example 3: temporary ARRAY: _TEMPORARY_. A temporary array is an array that only exists for the duration of the data step where it is defined. A temporary array is useful for storing constant values, which are used in calculations. In a temporary array there are no corresponding variables to identify the array elements **/ DATA TEMP_ARRAY; SET Sample_data; ARRAY numvars[*] _NUMERIC_; /* The initial numeric variable */ ARRAY newvars[*] px1-px3; /* The array of new numeric variables (placeholder) For the store the computed values */ ARRAY inival[3] _TEMPORARY_ (1.1, 1.2, 1.3); /* This temporary ARRAY provides initial values */ DO i = 1 TO dim(numvars); /* i will be dropped from the data */ newvars[i] = numvars[i] * inival[i]; /* calculate the values for the new variable */ END; DROP i; RUN; PROC PRINT DATA = TEMP_ARRAY; RUN; /*************************************************** Topic 4. Applications of SAS ARRAYs. ****************************************************/ /** Example 1: numeric array **/ DATA TIMES; INPUT TIME1 TIME2 TIME3 TIME4; DATALINES; 22.3 25.3 28.2 30.6 22.8 27.5 33.3 35.8 18.5 26.0 29.0 27.9 22.5 29.3 32.6 33.7 ; RUN; /* Using ARRAY to perform a repetitive task: Some detailed steps on how to access ARRAY and complete each record of the new variable SUMTIME. */ DATA TIME_SUM; SET TIMES; ARRAY TMARRAY[4] TIME1-TIME4; /* Declare a numeric ARRAY to store the four TIME variables for bulk processing */ *ARRAY TMARRY[*] TIME1-TIME4; /* This an alternative definition of ARRAY without specifying the dimension */ SUMTIME = 0; /* Initialize a new variable, SUMTIME, to start the loop */ DO I= 1 TO 4; /* Use DO-LOOP to access the ARRAY TMARRAY */ SUMTIME = SUMTIME + TMARRAY(I); /* To complete each record of SUMTIME - DO-LOOP processes each record of data set TIME_SUM wiht new variable SUMTIME. */ * OUTPUT; /* Obs TIME1 TIME2 TIME3 TIME4 SUMTIME I 1 22.3* 25.3 28.2 30.6 22.3* 1 2 22.3* 25.3* 28.2 30.6 47.6* 2 3 22.3* 25.3* 28.2* 30.6 75.8* 3 4 22.3* 25.3* 28.2* 30.6* 106.4* 4 */ END; OUTPUT; /* ==&gt; 22.3* 25.3* 28.2* 30.6* 106.4* 5 */ *DROP I; RUN; PROC PRINT DATA = TIME_SUM; RUN; /* Example 2. automatic numerical variable _NUMERIC_: Two variable lists, _NUMERIC_, and _CHARACTER_ are especially relevant for arrays. As the names imply, these variable lists reflect all of the numeric or character variables that are defined in the current DATA step when the variable list is specified. We can use these variable lists in the ARRAY statement, as shown here: array my_nums[*] _numeric_; array my_chars[*] _character_; These variable lists are especially helpful if you want your array to contain all of the numeric or character variables in an SAS data set referenced in a SAS is a statement that reads the data set. It is important to emphasize that the variable list refers to all variables of that type that are previously defined in the DATA step, not just those that exist in a previously referenced data set. */ DATA test; INPUT A B C D E; DATALINES; 1 . 1 0 1 0 . . 1 1 1 1 0 1 1 ; RUN; DATA Replace_Missings; SET test; /* Use the _NUMERIC_ variable list to associate all of */ /* the numeric variables with an array. */ ARRAY vars[*] _NUMERIC_; /* Loop through the array, changing all missing values to 0. */ DO I = 1 TO dim(vars); IF vars[i] = . THEN vars[i] = 0; /* Bulk processing through the DO-LOOP */ END; DROP I; RUN; PROC PRINT DATA = Replace_Missings;; RUN; /*************************************************** *************************************************** Topic 5. Reshape Data Sets **************************************************** ****************************************************/ /** Example 1. Reshape the wide table using an ARRAY. Date variables are recorded as formatted numerical variables **/ /* This working data set is a typical wide table */ DATA patient_visits; INPUT patient_ID $ (visit1-visit4) (: mmddyy10.); /* colon modifier specified format */ FORMAT visit1-visit4 mmddyy10.; DATALINES; Joe 01/05/2011 01/15/2011 01/25/2011 02/03/2011 Sam 01/07/2011 01/17/2011 01/27/2011 02/10/2011 Ron 01/09/2011 01/19/2011 01/29/2011 03/15/2011 Bob 01/11/2011 01/21/2011 01/31/2011 02/01/2011 ; RUN; /** converting the above wide table to a long table **/ DATA LONG_TABLE; SET patient_visits; /* Define an array to contain the visits. */ ARRAY visit[4] visit1-visit4; /* store the 4 variables VISIT1 - VISIT4 in the ARRAY. */ *ARRAY visit[4] _NUMERIC_; /* store the 4 variables VISIT1 - VISIT4 in the ARRAY. */ /* Loop through the array, assigning each element (visit) */ /* to the Date_of_Visit variable and then outputting it. */ DO i=1 TO DIM(visit); /* DIM() returns the number of variables */ date_of_visit = visit[i]; OUTPUT; END; /* Format and drop variables, as desired. */ FORMAT date_of_visit mmddyy10.; DROP visit1-visit4 i; RUN; PROC PRINT DATA = LONG_TABLE; RUN; /** Example 2. long table to wide table: We want to convert the LONG_TABLE to the original wide table: PATIENT_VISITS **/ /* Sort data set by Patient_ID and Date_of_Visit. */ PROC SORT DATA = LONG_TABLE; BY patient_ID date_of_visit; RUN; /** Converting LONG_TABLE to the original wide table **/ DATA widetable; SET LONG_TABLE; BY patient_ID; /* Sorting the dataset by patient_ID is crucial!!!! */ /* Define an array for the new visit variables. */ ARRAY visit[4] VISIT1-VISIT4; /* place holder */ /* Retain the variables that are associated with the array. */ RETAIN visit; /* retain the value of the previous visit until hit the FIRST.var */ /* Clear the visit variables and the counter for each new BY */ /* group (Patient_ID). */ IF FIRST.patient_ID THEN DO I = 1 TO DIM(VISIT); *VISIT[I] = .; counter = 0; END; /* Increment the counter that is used to reference the element */ /* of the array to assign a date. */ counter+ 1; /* Assign the date to the proper element of the array. */ visit[counter] = date_of_visit; /* Output one observation per BY group (Patient_ID). */ IF LAST.patient_ID THEN OUTPUT; /* important, output a complete record and then prepare the next record */ /* Format and drop variables, as desired. */ FORMAT visit : mmddyy10.; DROP date_of_visit I counter; RUN; PROC PRINT DATA = widetable; RUN; /**************************************************/ /** Example 3: transpose wide table to long table **/ /**************************************************/ DATA grades1; INPUT name $ hw1-hw6; DATALINES; Amy 6 8 4 8 7 8 Bob 3 5 5 7 5 5 Carol 7 8 8 7 8 9 Dave 10 9 9 8 10 9 Eve 6 6 8 6 9 7 ; RUN; /* SORT the dat by NAME since will process the records by names and */ PROC SORT DATA =grades1; BY name; RUN; PROC TRANSPOSE DATA = grades1 OUT = grades2; BY name; VAR hw1-hw6; RUN; PROC PRINT DATA = grades2; RUN; DATA LONG_GRADES; SET grades2; HW = _NAME_; GRADE = COL1; DROP _NAME_ COL1; RUN; PROC PRINT DATA = LONG_GRADES; RUN; /***************************************************/ /** Example 4: Transform longtable to wide table **/ /***************************************************/ PROC TRANSPOSE DATA = long_grades OUT = wide_grades (DROP = _NAME_); BY NAME ; ID HW; VAR GRADE; RUN; PROC PRINT DATA = wide_grades ; RUN; /************************************************************************ CONCLUDING REMARK BOTH PROC TRANSPOSE and ARRAY are equally convenient for reshaping data with two variables. However, if the data set has more than two variables, Using PROC TRANSPOSE to TRANSPOSE data can be very tedious. *************************************************************************/ "],["output-deliver-system-ods.html", "Chapter 13 Output Deliver System (ODS) 13.1 ODS Basics 13.2 ODS Syntax 13.3 Flexibility of ODS 13.4 ODS Styles 13.5 Learning Coding by Examples", " Chapter 13 Output Deliver System (ODS) We have introduced three Base SAS statistical graphics procedures (SGPLOT, SGSCATTER, and SGPANEL) that use ODS Graphics and provide a convenient syntax for creating a variety of graphs from raw data or procedure output. This chapter will introduce ODS in a little more detail. We will also learn how ODS manages procedure output and displays it in a variety of destinations, such as HTML and RTF. 13.1 ODS Basics ODS creates the output in the form of output objects. Each output object is comprised of two components. The data component contains the results of a procedure or a DATA step. The table definition tells SAS how to render the results. Once SAS creates all the output objects from an executed program, it then just needs to figure out where to send the objects. SAS ODS destinations (i.e., file format) (0). LISTING (SAS default ODS destination) (1). HTML (2). OUTPUT (3). Printer Family format: PDF or PS (4). RTF 13.1.1 Some Technical Terms Destinations – Destinations are the file types and locations to which ODS routes the output from SAS. ODS can be used to route quality presentation files, suitable for publishing, to various destinations, including LISTING (default), HTML, RTF, PRINTER, and PDF. ODS can also store results in a SAS data set when we use the ODS OUTPUT statement. Objects – Output objects are created by ODS to store the formatted results of most SAS procedures. One can select output objects to tailor the results. An output object consists of the tabular data component from a SAS procedure. Formatting instructions provided by a table template that is unique to that SAS procedure. Styles – Styles define the presentation attributes of a report, such as font and color. ODS uses style definitions, or templates, to enhance the visual appearance of the output in those destinations that support styles. Note that styles do not apply to the LISTING and OUTPUT destinations. 13.1.2 SAS Default Destination: LISTING The default ODS destination is LISTING. This is where SAS sends the output. This ODS destination is the standard output window. If we choose a specific ODS destination other than LISTING and don’t want to print out anything in the output window. We should close this ODS destination using the command ODS LISTING CLOSE before opening other ODS destinations. It is a good practice to keep LISTING open since it is more convenient when checking the output results and debugging the code. 13.2 ODS Syntax The basic syntax of ODS is given by ODS output-type PATH path-name FILE = Filename-and-Path STYLE = Style-Name; PROC some proc; ODS output-type CLOSE; output-type - output file destination chosen from HTML, PDF, RTF, etc. The default is LISTING and is on. If we don’t want to print the outputs in the output window, we can close the default destination. PATH represents the statement used in the case of HTML output. In other types of output, we include the path in the file name. STYLE represents one of the in-built styles available in the SAS environment. We will discuss different output styles later in more detail. The following figure demonstrates a simple ODS application. In the above example, the output file destination is RTF, and the output file PATH and FILE name are combined. We did not specify an output style, the default style was used. Since the default output destination LISTING was not closed, the results were also sent to the output window. After executing the ODS code block, we can open the output file in the specified file location and view the content of the file as shown below. 13.3 Flexibility of ODS This section demonstrates the flexibility of using ODS to generate different SAS output results. 13.3.1 HTML The HTML format output is favorable in many cases particularly when the result is published on the web together with other results to give users a better experience when consuming the analytic outcomes. ODS can generate HTML outputs with different output styles to make HTML aesthetically better. The following example shows how to generate ODS HTML outputs using PATH and FILE separately and jointly. 13.3.2 Multiple ODS Putputs We can also generate multiple ODS outputs in a single data or procedure step. The following is an illustrative example that generates three different outputs at once. In the above example, we close LISTING before opening other destinations. But LISTING was opened at the very end to allow the default destination for the future outputs. The ODS files were successfully generated and sent to the designated location. 13.4 ODS Styles When we output information to a SAS ODS format, the tables, graphs, and text are defined with default colors and fonts. There are several built-in ODS styles that we can select. Each style is based on some theme or purpose. Using these different styles appropriately will make analytic communications more effective and more professional. For example, when publishing the analysis results on the web page or creating web-based presentations, we can choose output styles that are consistent with the overall design of the web pages or the presentations in terms of background colors, font size/ families, etc. The following is a partial list of ODS styles. An example of Raven-style ODS output is given below. Note that when creating styled ODS outputs in PDF or RTF, the combined PATH and FILE should be used. The standalone PATH and FILE method will NOT work for these two destinations. Since the default LISTING was not closed, the results were also printed out in the output window. Finally, the following figure showcases a few styled ODS outputs with self-explanatory titles. 13.5 Learning Coding by Examples This section gives more examples of ODS with a summary of the ODS. At the very end, an SAS MACRO was used to produce the showcases stylish ODS outputs in the previous section. Mode detailed discussion about SAS MACROs will be given in a later chapter. /************************************************** Topics: 1. ODS Basics - Opening and Closing ODS 2. ODS with Multiple Procedures 3. ODS OUTPUT Enhancements 4. Advanced ODS HTML - Enhanced Web Page 5. SAS ODS Graphics Your permanent library should be something like this: LIBNAME ods &quot;\\\\Client\\C$\\cpeng\\sta311\\ods&quot;; ***************************************************/ DM &#39;CLEAR LOG&#39;; DM &#39;CLEAR OUTPUT&#39;; /**************************************************************************** Overview of Output Delivery System (ODS) 1. SAS output of procedure (including graphics) shows in the Results window. Although SAS is creating files on the server (RamCloud) or a local computer as you add to your results, these are effectively hidden from you in a temporary folder within C:\\temp\\SAS Temporary Files\\. The graphics will be wiped out when exiting the SAS session. 2. The question is how to save graphics in the designated location, file&#39;s ODS destination, and in the desired format automatically. Format: The format of the output file can be chosen from listing, RTF (for use in Word documents), pdf, and HTML. ODS Destination: The formats of the output files corresponding to the ODS LISTING(default), ODS RTF, ODS PDF, and ODS HTML destinations, respectively. Location: We can provide a physical location to store an output file in the desired format. ODS Syntax ODS output-file-destination * file destinations: LISTING, RFT, PDF, HTML; PATH path name FILE = Filename and Path STYLE = StyleName; * PROC some procedures... ODS output-file-destination CLOSE; **********************************************************************/ OPTIONS PS = 58 LS = 72 NODATE NONUMBER; LIBNAME odsout &#39;C:\\STA311\\ODS&#39;; /** Working data sets **/ DATA PENN_GOLF; INPUT @1 SID $3. @4 Name $18. /* informat */ @23 Architect $16. @40 Year @45 Type $ @54 Par Yards Slope USGA; DATALINES; 102 Penn State Blue Willie Park,Jr. 1921 Public 72 6525 128 72.0 101 Toftrees Ed Ault 1968 Resort 72 7018 134 74.3 103 Centre Hills Alex Findlay 1921 Private 71 6392 128 71.2 104 Lewistown CC . Private 72 6779 125 72.3 105 State College Elks Lowell Erdman 1973 SemiPri 71 6369 123 70.9 106 Park Hills CC James Harrison 1966 SemiPri 70 6004 126 69.3 107 Sinking Valley CC Ed Ault 1967 SemiPri 72 6755 132 73.4 108 Williamsport CC A.W. Tillinghast 1909 Private 71 6489 131 71.9 109 Standing Stone GC Geoffrey Cornish 1973 SemiPri 70 6593 120 71.4 110 Bucknell GC 1960 SemiPri 70 6253 132 70.0 111 Mount Airy Lodge Hal Purdy 1972 Resort 72 7123 140 74.3 ; RUN; /** By default, the ODS LISTING is open. So you will see the output **/ PROC PRINT DATA = PENN_GOLF; RUN; /*************************************************************************** Topic #1: ODS Basics - Opening and Closing ODS 1) ODS creates your output in the form of output objects. Each output object is comprised of two components. (a) The data component contains the results ?think about numbers ?of a procedure or a DATA step. (b) The table definition tells SAS how to render the results ?think about structure. 2. Once SAS creates all of the output objects from an executed program, it then just needs to figure out where to send the objects. SAS ODS destinations (1). LISTING (default output) (2). Printer Family format: PDF or PS (3). RTF (4). HTML ****************************************************************************/ /*************/ /** Example 0: Default ODS destination - LISTING. It is open by default. If you close the LISTING destination, The PROC PRINT procedure will not print out anything in the output window. **/ ODS LISTING CLOSE; /* close the ODS LISTING, the log file will give an error message */ PROC PRINT DATA = PENN_GOLF; RUN; /* Log File WARNING: No output destinations are active. NOTE: There were 11 observations read from the data set WORK.PENN_GOLF. NOTE: PROCEDURE PRINT used (Total process time): real time 0.00 seconds cpu time 0.00 seconds */ /* We next open ODS LISTING and then print out the same data */ OPTIONS PS =30 LS = 120 NODATE NONUMBER; /* Adjust page size and line size to make a better-looking output */ ODS LISTING; /* Open the ODS LISTING, the log file will give NO error message */ PROC PRINT DATA = PENN_GOLF; TITLE &quot;Some Golf Courses in PENN&quot;; RUN; /****************************************************************/ /* Example 1: Opening and Closing ODS Destinations - PDF */ /* Need to specify the physical location to save the generated file with an appropriate name and the correct file destination (extension). */ ODS LISTING CLOSE; ODS PDF FILE = &#39;C:\\STA311\\ODS\\golf00.pdf&#39;; PROC PRINT DATA = PENN_GOLF NOOBS; TITLE &#39;Some of the penngolf data set variables: PDF&#39;; ID name; VAR year type par yards; RUN; ODS PDF CLOSE; /* Always close the ODS destination after finishing the current block */ /* Note: I did close ODS LISTING, When I ran the above block, a PDF file was generated and sent to the folder. At the same time, the output was also generated in the output window. */ ODS LISTING; /****************************************************************/ /* Example 2: Opening and Closing ODS Destinations - HTML */ ODS HTML file = &#39;C:\\STA311\\ODS\\golf0.html&#39;; PROC PRINT DATA = PENN_GOLF NOOBS; TITLE &#39;Some of the penngolf data set variables: HTML&#39;; ID name; VAR year type par yards; RUN; ODS HTML CLOSE; /***************************************************************/ /* Example 3: Opening and Closing ODS Destinations - RTF */ ODS RTF file = &#39;C:\\STA311\\ODS\\golf0.rtf&#39;; PROC PRINT DATA = PENN_GOLF NOOBS; TITLE &#39;Some of the penngolf data set variables: RTF&#39;; ID name; VAR year type par yards; RUN; ODS RTF CLOSE; /*********************/ /*** IMPORTANT!!! ***/ /*********************/ ODS LISTING; /* It is a good practice to leave ODS LISTING open at the end of a code block. */ /*******************************************/ /** Example 4. A more efficient approach: We can also generate all three different file at the procedure**/ ODS LISTING CLOSE; /* close the listing destination before creating RTF, HTML and PDF */ ODS RTF file = &#39;C:\\STA311\\ODS\\golf01.rtf&#39;; ODS HTML file = &#39;C:\\STA311\\ODS\\golf01.HTML&#39;; ODS PDF file = &#39;C:\\STA311\\ODS\\golf01.pdf&#39;; PROC PRINT DATA = PENN_GOLF NOOBS; TITLE &#39;Some of the penngolf data set variables: Multiple ODS Destinations&#39;; ID name; VAR year type par yards; RUN; ODS PDF CLOSE; ODS HTML CLOSE; ODS RTF CLOSE; ODS LISTING; /* Open this destination for the next output in the output window */ /*************************************************************************** Topic #2: ODS OUTPUT Enhancements BODYTITLE - STYLE = option: changes the appearance of the default HTML output by using one of the many predefined style templates built into SAS. SELECT statement: tells SAS the specific output objects that we want to display. To select specific output objects, simply place an ODS SELECT statement within the relevant procedure. ****************************************************************************/ /** Example 1: Bodytitle **/ ODS LISTING CLOSE; /* Close LOSTING before generating ODS output */ ODS RTF file = &#39;C:\\STA311\\ODS\\bodytitle.rtf&#39; BODYTITLE; /* BODYTITLE option in the ODS RTF statement tells SAS to instead put titles and footnotes in the main part of the RTF document. */ PROC PRINT DATA = penn_golf;* NOOBS; TITLE &#39;Some Par 72 Pennsylvania Golf Courses&#39;; ID name; VAR year type yards; WHERE par = 72; RUN; ODS RTF CLOSE; ODS LISTING; /* Open LISTING for next LISTING outputs */ /**** Available STYLEs ****/ PROC TEMPLATE; /* This procedure will print out all available styles in the output window */ LIST STYLES; RUN; /**************************************** 2 Styles.Analysis Style 3 Styles.BarrettsBlue Style 4 Styles.BlockPrint Style 5 Styles.DTree Style 6 Styles.Daisy Style 7 Styles.Default Style 8 Styles.Dove Style 9 Styles.EGDefault Style 10 Styles.Excel Style 11 Styles.FancyPrinter Style 12 Styles.Festival Style 13 Styles.FestivalPrinter Style 14 Styles.Gantt Style 15 Styles.GrayscalePrinter Style 16 Styles.HTMLBlue Style 17 Styles.Harvest Style 18 Styles.HighContrast Style 19 Styles.HighContrastLarge Style 20 Styles.Journal Style 21 Styles.Journal1a Style 22 Styles.Journal2 Style 23 Styles.Journal2a Style 24 Styles.Journal3 Style 25 Styles.Journal3a Style 26 Styles.Listing Style 27 Styles.Meadow Style 28 Styles.MeadowPrinter Style 29 Styles.Minimal Style 30 Styles.MonochromePrinter Style 31 Styles.Monospace Style 32 Styles.Moonflower Style 33 Styles.Netdraw Style 34 Styles.NoFontDefault Style 35 Styles.Normal Style 36 Styles.NormalPrinter Style 37 Styles.Ocean Style 38 Styles.Pearl Style 39 Styles.PearlJ Style 40 Styles.Plateau Style 41 Styles.PowerPointDark Style 42 Styles.PowerPointLight Style 43 Styles.Printer Style 44 Styles.Raven Style 45 Styles.Rtf Style 46 Styles.Sapphire Style 47 Styles.SasDocPrinter Style 48 Styles.SasWeb Style 49 Styles.Seaside Style 50 Styles.SeasidePrinter Style 51 Styles.Snow Style 52 Styles.StatDoc Style 53 Styles.Statistical Style 54 Styles.Word Style 55 Styles.vaDark Style 56 Styles.vaHighContrast Style 57 Styles.vaLight Style ********************************************/ /***********************/ /** Example 2: Style **/ ODS LISTING CLOSE; ODS HTML file = &#39;C:\\STA311\\ODS\\meadow.html&#39; style = meadow; /** STYLE= option to tell SAS to use the meadow style when displaying the HTML output **/ PROC PRINT DATA = penn_golf NOOBS; TITLE &#39;Some of the penngolf data set variables&#39;; ID name; VAR year type par yards; RUN; ODS HTML CLOSE; ODS LISTING; /************************************************************/ /** Example 3: create a data set using ODS output statement**/ PROC SORT DATA = PENN_GOLF; BY PAR; RUN; PROC MEANS DATA = PENN_GOLF; BY par; VAR yards; TITLE &#39;Pennsylvania Golf Courses by Par&#39;; ODS OUTPUT Summary = summout; RUN; ODS LISTING CLOSE; ODS HTML file = &#39;C:\\STA311\\ODS\\PowerPointLight.html&#39; style = PowerPointLight; /* Use a different ODS HTML style */ PROC PRINT DATA = summout NOOBS; TITLE &#39;The summout data set&#39;; RUN; ODS HTML CLOSE; ODS LISTING; /************************************/ /** Example 4. SELECT - statement **/ PROC SORT DATA = penn_golf OUT = golfbypar; BY par; RUN; ODS LISTING CLOSE; ODS HTML file = &#39;C:\\STA311\\ODS\\Statistical.html&#39; style = Statistical; /* Use a different ODS HTML style */ PROC MEANS data = golfbypar; by par; title &#39;Par 70 Golf Courses&#39;; ODS SELECT Means.ByGroup1.Summary; RUN; ODS HTML CLOSE; ODS LISTING; /************************************************************************** Topic #3: Advanced ODS HTML - Enhanced Web Page (Optional) When we create an HTML in the above topic 2, we simply open the HTML destination using the HTML keyword in the ODS statement. Simple enough! In this topic, we&#39;ll extend what we learned by: 1. creating HTML output from multiple procedures at once; 2. creating HTML output with a table of contents; and 3. using options to specify links and paths. ODS HTML Specifications: 1. BODY= option tells SAS where we want to store the HTML output generated from the subsequent PRINT and REPORT procedures. 2. CONTENTS= option tells SAS where we want to store the table of contents. 3. FRAME= option gives SAS a place to store the HTML page containing the integrated table of contents and body file. Note that the FRAME= option and the CONTENTS= option go together. That is, if we include the FRAME= option in your ODS HTML statement, you must also include the CONTENTS= option. ************************************************************************/ ODS LISTING CLOSE; ODS HTML BODY = &#39;C:\\STA311\\ODS\\golf3.html&#39; CONTENTS = &#39;C:\\STA311\\ODS\\golf3toc.html&#39; FRAME = &#39;C:\\STA311\\ODS\\golf3frame.html&#39;; /* PROC PRINT */ PROC PRINT DATA = penn_golf NOOBS; TITLE &#39;Some Par 72 Pennsylvania Golf Courses&#39;; ID name; VAR year type yards; WHERE par = 72; RUN; /* PROC REPORT --- will study PROC REPORT next week, more details to come.... */ PROC REPORT DATA = penn_golf NOWINDOWS HEADLINE HEADSKIP; TITLE &#39;Average Size of Some PA Courses&#39;; COLUMN type par yards; DEFINE type /GROUP; DEFINE yards / ANALYSIS MEAN FORMAT = 6.1 WIDTH = 10; DEFINE par / ANALYSIS MEAN FORMAT = 4.1 WIDTH = 10; RUN; ODS HTML CLOSE; ODS LISTING; /****************************************************** Topic #4: ODS Graphics *******************************************************/ /* Woeking dataset taken from James Forbes&#39; Altimeter (1857) Bringing water to a boil throughout the Alps */ DATA forbes; INPUT id boil pressure; LABEL boil = &quot;Boiling Point (degrees F)&quot; pressure = &quot;Air Pressure (inches Hg)&quot;; DATALINES; 1 194.5 20.79 2 194.3 20.79 3 197.9 22.40 4 198.4 22.67 5 199.4 23.15 6 199.9 23.35 7 200.9 23.89 8 201.1 23.99 9 201.4 24.02 10 201.3 24.01 11 203.6 25.14 12 204.6 26.57 13 209.5 28.49 14 208.6 27.76 15 210.7 29.04 16 211.9 29.88 17 212.2 30.06 ; RUN; /* Titles affect all forms of output */ TITLE &quot;Boiling Point and Altitude&quot;; TITLE2 &quot;James D. Forbes, 1857&quot;; /**** Example 1 ****/ /* RTF output, for MS Word documents */ ODS RTF FILE =&quot;C:\\STA311\\ODS\\graphics-example.rtf&quot;; PROC SGPLOT DATA = forbes; SCATTER Y = boil X= pressure; RUN; ODS RTF CLOSE; /**** Example 2 ****/ /* PDF output, for Acrobat documents */ ODS PDF FILE = &quot;C:\\STA311\\ODS\\graphics-example.pdf&quot;; PROC SGPLOT DATA = forbes; SCATTER Y = boil X = pressure; RUN; ODS PDF CLOSE; /**** Example 3 ****/ /* PNG output, for a variety of uses */ ODS HTML GPATH = &quot;C:\\STA311\\ODS&quot;; PROC SGPLOT DATA = forbes; SCATTER Y = boil X = pressure; RUN; ODS HTML CLOSE; * No need to close the HTML destination; /**** Example 4 ****/ /* As a final note, remember that you could save output from a single PROC to more than one output destination, simultaneously. We could have done all three like this: */ ODS RTF FILE=&quot;C:\\STA311\\ODS\\graphics-example-02.rtf&quot;; ODS PDF FILE = &quot;C:\\STA311\\ODS\\graphics-example-02.pdf&quot;; ODS HTML GPATH = &quot;C:\\STA311\\ODS&quot;; PROC SGPLOT DATA = forbes; SCATTER Y = boil X = pressure; RUN; ODS RTF CLOSE; ODS PDF CLOSE; /*********************************************************************** Topic #5: Other format graphics with ODS (1) Saving multiple graphs using the sashelp.class data to draw scatterplots of weight by age and weight by height. Save these in all three formats discussed here. (2) JPG files Look up the ODS HTML command and find the DEVICE option (Base SAS - Output Delivery System User&#39;s Guide - ODS Statements). Save files from exercise (1) in jpg or jpeg format. ***********************************************************************/ /******************/ /* Example 1 *******************/ TITLE; ODS RTF FILE = &quot;C:\\STA311\\ODS\\graphics-example-03.rtf&quot;; ODS PDF FILE = &quot;C:\\STA311\\ODS\\graphics-example-03.pdf&quot;; ODS HTML GPATH = &quot;C:\\STA311\\ODS\\&quot;; PROC SGPLOT DATA = sashelp.class; SCATTER Y = weight X = age; PROC SGPLOT DATA = sashelp.class; SCATTER Y = weight X = height; run; ODS RTF CLOSE; ODS PDF CLOSE; /******************** * Example 2 *********************/ ODS HTML GPATH = &quot;C:\\STA311\\ODS\\&quot; DEVICE = jpg; PROC SGPLOT DATA = sashelp.class; SCATTER Y = weight X = age; PROC SGPLOT DATA = sashelp.class; SCATTER Y = weight X = height; run; /******************************************** ** Optional Topic: MACRO; *********************************************/ /*** Sample ODS Styles in HTML ***** Since I repeat the same process to generate outputs in different ODS styles, I will write a SAS MACRO to avoid copying and pasting and make several MACRO calls to accomplish our task. Writing SAS MACROs is outside the scope of this class. *****************************************************************************/ /* column input */ DATA Orange; /* stored in the temporary library */ INPUT state $ 1-10 early 12-14 late 16-18; DATALINES; Florida 130 90 California 37 26 Texas 1.3 .15 Arizona .65 .85 ; RUN; %MACRO ODSSTYLE(STYLE = ); ODS HTML FILE =&quot;C:\\STA311\\ODS\\myOrange&amp;STYLE..HTML&quot; STYLE =&amp;STYLE; PROC PRINT DATA = Orange; TITLE &quot;Output Style &amp;STYLE: HTML&quot;; RUN; ODS HTML CLOSE; /* ODS must be closed! */ %MEND; %ODSSTYLE(STYLE=HARVEST); %ODSSTYLE(STYLE=Ocean); %ODSSTYLE(STYLE=MeadowPrinter); %ODSSTYLE(STYLE=PowerPointDark); %ODSSTYLE(STYLE=Excel); %ODSSTYLE(STYLE=BlockPrint); %ODSSTYLE(STYLE=BarrettsBlue); %ODSSTYLE(STYLE=EGDefault); "],["generating-analysis-reports.html", "Chapter 14 Generating Analysis Reports 14.1 PROC REPORT Syntax 14.2 ODS Reports 14.3 Learning Coding by Examples", " Chapter 14 Generating Analysis Reports Drafting an analysis report is the final step for many data analyses. SAS has a very useful report procedure that allows users to generate a nice-looking profession-like report. To be more specific, PROC REPORT can do the following reporting tasks Assigning column formats; Defining column headings; Specifying the order of the contents the justification, width, and spacing of the columns; Grouping the character variables in reports; Create statistical summaries such as subtotals, grand totals, and averages; 14.1 PROC REPORT Syntax We first look at the report syntax. Notice that the DEFINE statements as well as other statements in the syntax define different features of the report. The term following the ‘/’ specifies the way the REPORT procedure uses the column. Columns can be defined as: GROUP - puts observations into categories; DISPLAY - displays values for each observation; ANALYSIS - contributes values to a calculation or statistic; ORDER - defines the order of the report rows; ACROSS - creates columns for each of its values; COMPUTED - its values are created in a COMPUTE block; Next, we define a working data set and use it to generate two basic reports. More reports with different types of information will be given in the last lab section. /** Working data set and formats **/ PROC FORMAT; VALUE gendfmt 0=&#39; Man&#39; 1=&#39; Woman&#39;; VALUE racefmt 0=&#39; Nonwhite&#39; 1=&#39; White&#39;; VALUE meanfmt low - 99 = &#39;white&#39; 100 - high = &#39;red&#39;; QUIT; DATA DEMOGRAPHICS; INPUT patient $3. gender 3. height 4.1 weight 4. age 5.1 race 3. drug $7.; *FORMAT height age 4.1 gender gendfmt. race racefmt.; *LABEL patient=&#39;Patient&#39; gender=&#39;Sex&#39; height=&#39;Height&#39; weight=&#39;Weight&#39; age=&#39;Age&#39; race=&#39;Race&#39; drug=&#39;Drug&#39;; DATALINES; 001 1 74.4 257 67.9 1 Active 002 1 63.1 168 36.7 0 Active 003 1 69.6 264 74.6 0 Placebo 004 1 63.2 270 73.8 1 Placebo 005 1 67.8 209 57.8 1 Active 006 0 56.7 116 47.5 1 Active 007 1 70.4 150 47.8 1 Active 008 1 68.5 172 82.6 1 Active 009 0 66.4 212 25.1 0 Active 010 1 68.1 216 60.6 1 Placebo 011 1 62.8 193 80.0 1 Active 012 1 73.6 198 77.4 1 Active 013 0 59.8 117 72.3 1 Active 014 0 74.7 179 37.4 0 Placebo 015 1 73.0 195 21.4 1 Active 016 1 57.7 213 27.3 1 Active 017 1 59.9 199 43.1 1 Active 018 1 70.2 219 67.3 0 Active 019 1 68.6 236 62.2 1 Placebo 020 1 70.7 255 66.4 1 Active 021 1 71.6 228 27.3 1 Active 022 1 58.9 111 68.3 1 Active 023 1 65.7 194 67.1 0 Active 024 1 63.2 234 65.2 0 Active 025 1 72.4 162 56.1 0 Placebo ; RUN; PROC PRINT DATA = DEMOGRAPHICS; TITLE &quot;RAW Data&quot;; RUN; We defined several formats for those numerically encoded categorical variables so that the meaningful names will be printed out in the report. The first example did not calculate any summarized statistics. Some of the column names were relabeled to better fit the reported table. Example 1: CROSS option ==&gt; Two-way table and output as a SAS data set! PROC REPORT DATA = DEMOGRAPHICS out=profit; COLUMNS gender drug height weight; DEFINE gender / GROUP FORMAT = gendfmt.; /* Formatting GENDER */ DEFINE drug / ACROSS &#39;Treatment Type&#39;; /* Formatting DRUG */ DEFINE height / MEAN FORMAT = 4.1 WIDTH = 8; DEFINE weight / MEAN FORMAT = 4. WIDTH = 8; TITLE &quot;Basic Report: Multiple-Grouping - Two-way Table&quot;; RUN; The following is the partial output table. Next, we generate a summarized statistics table using the same data. Example 2 CROSS option ==&gt; Two-way table and output as a SAS data set! PROC REPORT DATA = DEMOGRAPHICS out=profit; COLUMNS gender drug height weight; DEFINE gender / GROUP FORMAT = gendfmt.; /* Formatting the variable GENDER */ DEFINE drug / ACROSS &#39;Treatment Type&#39;; /* Formatting the variable DRUG */ DEFINE height / MEAN FORMAT = 4.1 WIDTH = 8; DEFINE weight / MEAN FORMAT = 4. WIDTH = 8; TITLE &quot;Basic Report: Multiple-Grouping - Two-way Table&quot;; RUN; Example 3 Using COMPUTED statement to define new variables. There are some restrictions on using COMPUTED statement We can only use variables to the left of the current column in the calculations (we can assign a value to a variable to the right, but we can’t read it). Another important restriction is that unqualified columns must have usage DISPLAY. Just like the following example. If we want to perform calculations on an analysis variable, we must qualify the name with the name of a statistic. (see Example 6). PROC REPORT DATA = DEMOGRAPHICS; COLUMNS Patient height weight ratio; DEFINE patient / WIDTH =7; DEFINE height / DISPLAY FORMAT = 4.1 WIDTH = 8; DEFINE weight / DISPLAY WIDTH = 8; DEFINE RATIO /COMPUTED &#39;Ratio&#39;; /* starting computing */ COMPUTE RATIO; RATIO = height/weight; ENDCOMP; /* need to close compute */ TITLE &quot;Basic Report: Height-Weight Ratio&quot;; RUN; The partial output of the above report is given by 14.2 ODS Reports PROC REPORT has some decorative options that can be used to enhance the report (headers). NOWINDOWS suppresses the REPORT window and directs the report to the output window HEADLINE creates a horizontal line between the column headers and the body of the report HEADSKIP creates a blank line between the column headers and the body of the report STYLE(Column and Header) component option is specified to instruct SAS to use the color “Blue” for the background and “White” for the foreground of each cell on the report output. We can also use the output STYLEs through ODS to create REPORTs with different ODS styles! Example 4 Enhanced report with ODS report with WCU color in the background. ODS HTML; /* We add colors to the table, we need a file destination that can render the colors. The default LISTING destination cannot render the colors specified in the STYLE option.*/ PROC REPORT DATA = DEMOGRAPHICS NOWINDOWS HEADLINE HEADSKIP STYLE(COLUMN)=[Background=Purple Foreground = Gold Cellspacing = 10]; COLUMNS patient gender height weight age race drug; DEFINE patient / DISPLAY &#39;PTID&#39; WIDTH = 4; /* Rename patient as PTID, column width = 4 */ DEFINE gender / DISPLAY FORMAT = gendfmt.; /* Formatting the variable GENDER */ DEFINE height / ANALYSIS &#39;HT&#39; FORMAT = 4.1; /* */ DEFINE weight / ANALYSIS &#39;WT&#39; FORMAT = 4.; DEFINE age / DISPLAY FORMAT = 3.1; DEFINE race / DISPLAY FORMAT = racefmt.; DEFINE drug / DISPLAY WIDTH = 8; TITLE &quot;Basic Report: Column Style&quot;; RUN; ODS HTML CLOSE; The partial output is given by We can also add a built-in style for the above report by simply adding a Raven style name to the output destination. ODS LISTING CLOSE; ODS HTML file = &#39;/home/u50445699/My311/ReportRaven.html&#39; style = Raven; /* Raven style! */ PROC REPORT DATA = DEMOGRAPHICS NOWINDOWS HEADLINE HEADSKIP STYLE(COLUMN)=[Background=Purple Foreground = Gold Cellspacing = 10]; COLUMNS patient gender height weight age race drug; DEFINE patient / DISPLAY &#39;PTID&#39; WIDTH = 4; /* Rename patient as PTID, column width = 4 */ DEFINE gender / DISPLAY FORMAT = gendfmt.; /* Formatting the variable GENDER */ DEFINE height / ANALYSIS &#39;HT&#39; FORMAT = 4.1; /* */ DEFINE weight / ANALYSIS &#39;WT&#39; FORMAT = 4.; DEFINE age / DISPLAY FORMAT = 3.1; DEFINE race / DISPLAY FORMAT = racefmt.; DEFINE drug / DISPLAY WIDTH = 8; TITLE &quot;Basic Report: Column Style&quot;; RUN; ODS HTML CLOSE; ODS LISTING; The partial ODS report is given in the following figure. 14.3 Learning Coding by Examples This section provides a few more examples to illustrate various reports and enhancements. Since ODS reports need to a particular folder of the machine that runs the program, users need to replace the file path in the examples. /*********************************************************************** Topics: 1. PROC REPORT: Basics 2. Enhancement of Report 3. ODS with PROC REPORT ************************************************************************/ OPTIONS PS = 74 LS = 74 NONUMBER NODATE; DM OUTPUT &#39;CLEAR&#39;; DM LOG &#39;CLEAR&#39;; /** Working data set and formats **/ PROC FORMAT; VALUE gendfmt 0=&#39; Man&#39; 1=&#39; Woman&#39;; VALUE racefmt 0=&#39; Nonwhite&#39; 1=&#39; White&#39;; VALUE meanfmt low - 99 = &#39;white&#39; 100 - high = &#39;red&#39;; QUIT; DATA DEMOGRAPHICS; INPUT patient $3. gender 3. height 4.1 weight 4. age 5.1 race 3. drug $7.; *FORMAT height age 4.1 gender gendfmt. race racefmt.; *LABEL patient=&#39;Patient&#39; gender=&#39;Sex&#39; height=&#39;Height&#39; weight=&#39;Weight&#39; age=&#39;Age&#39; race=&#39;Race&#39; drug=&#39;Drug&#39;; DATALINES; 001 1 74.4 257 67.9 1 Active 002 1 63.1 168 36.7 0 Active 003 1 69.6 264 74.6 0 Placebo 004 1 63.2 270 73.8 1 Placebo 005 1 67.8 209 57.8 1 Active 006 0 56.7 116 47.5 1 Active 007 1 70.4 150 47.8 1 Active 008 1 68.5 172 82.6 1 Active 009 0 66.4 212 25.1 0 Active 010 1 68.1 216 60.6 1 Placebo 011 1 62.8 193 80.0 1 Active 012 1 73.6 198 77.4 1 Active 013 0 59.8 117 72.3 1 Active 014 0 74.7 179 37.4 0 Placebo 015 1 73.0 195 21.4 1 Active 016 1 57.7 213 27.3 1 Active 017 1 59.9 199 43.1 1 Active 018 1 70.2 219 67.3 0 Active 019 1 68.6 236 62.2 1 Placebo 020 1 70.7 255 66.4 1 Active 021 1 71.6 228 27.3 1 Active 022 1 58.9 111 68.3 1 Active 023 1 65.7 194 67.1 0 Active 024 1 63.2 234 65.2 0 Active 025 1 72.4 162 56.1 0 Placebo ; RUN; PROC PRINT DATA = DEMOGRAPHICS; TITLE &quot;RAW Data&quot;; RUN; /************************************************************************/ /*** Topic 1 - Basic List Report - DEFINE Statement and Options ***/ /************************************************************************/ /*** The term following the &#39;/&#39; specifies the way the REPORT procedure uses the column. Columns can be defined as: 1. GROUP - puts observations into categories 2. DISPLAY - displays values for each observation 3. ANALYSIS - contributes values to a calculation or statistic 4. ORDER - defines the order of the report rows 5. ACROSS - creates columns for each of its values 6. COMPUTED - its values are created in a COMPUTE block. ***/ ** Example 1: Dropping three variables: AGE, RACE, and DRUG; (1). Attach a statistic such as SUM, MEANS, SUMMARY, UNIVARIATE, etc. to a variable or more variables. (2). One cannot see the effect of individual value. Once a group variable is jointly used with the requested statistic, we will see the descriptive statistics clearly. We include Patient ID in the report, we cannot see the effect of summary statistics!! **/ PROC REPORT DATA = DEMOGRAPHICS; COLUMNS patient gender (height weight),MEAN; DEFINE patient / DISPLAY &#39;PTID&#39; WIDTH = 4; /* Rename patient as PTID, column width = 4 */ DEFINE gender / GROUP FORMAT = gendfmt.; /* Formatting the variable GENDER */ DEFINE height / DISPLAY FORMAT = 4.1 WIDTH = 8; DEFINE weight / DISPLAY FORMAT = 4. WIDTH = 8; TITLE &quot;Basic Report: Single summary statistics - MEAN&quot;; RUN; /** Example 2: Drop Patient ID and use the group option! We now can see the summarized statistics! **/ PROC REPORT DATA = DEMOGRAPHICS OUT = mysummaryStats; COLUMNS gender (height weight),MEAN; DEFINE gender / GROUP FORMAT = gendfmt.; /* Formatting GENDER */ DEFINE height / DISPLAY FORMAT = 4.1 WIDTH = 8; DEFINE weight / DISPLAY FORMAT = 4. WIDTH = 8; TITLE &quot;Basic Report: Group MEANs&quot;; RUN; /** Example 3: Multi-grouping: still one-way table!! **/ PROC REPORT DATA = DEMOGRAPHICS; COLUMNS gender drug (height weight),MEAN; DEFINE gender / GROUP FORMAT = gendfmt.; /* Formatting the variable GENDER */ DEFINE drug / GROUP; /* Formatting the variable DRUG */ DEFINE height / DISPLAY FORMAT = 4.1 WIDTH = 8; DEFINE weight / DISPLAY FORMAT = 4. WIDTH = 8; TITLE &quot;Basic Report: Multi-Grouping - One Ways Table&quot;; RUN; /** Example 4: multiple descriptive statistics: **/ PROC REPORT DATA = DEMOGRAPHICS; COLUMNS gender (height weight),(N mean STD); DEFINE gender / GROUP FORMAT = gendfmt.; /* Formatting the variable GENDER */ DEFINE height / ANALYSIS FORMAT = 4.1 WIDTH = 8; DEFINE weight / ANALYSIS FORMAT = 4. WIDTH = 8; TITLE &quot;Basic Report: Multiple Summary Statistics&quot;; RUN; /** Example 5: Alternative method of quantification! **/ PROC REPORT DATA = DEMOGRAPHICS; COLUMNS Patient height weight ratio; DEFINE patient / WIDTH =7; DEFINE height / ANALYSIS FORMAT = 4.1 WIDTH = 8; DEFINE weight / ANALYSIS FORMAT = 4.0 WIDTH = 8; DEFINE RATIO /COMPUTED &#39;Ratio&#39;; COMPUTE RATIO; /* The sum of individual observation is itself! */ /* height.SUM: The extension is required! */ /* height /weight ==&gt; produce error!! */ RATIO = height.SUM/weight.SUM; ENDCOMP; TITLE &quot;Basic Report: Height-Weight Ratio&quot;; RUN; /********************************************************************/ /*** Topic 2 - Enhancing the Appearance of PROC REPORT Output ***/ /********************************************************************/ /** Example 1 **/ /** Modify the default column header **/ PROC REPORT DATA = DEMOGRAPHICS NOWINDOWS HEADLINE HEADSKIP; COLUMNS patient gender height weight age race drug; DEFINE patient / DISPLAY &#39;PTID&#39; WIDTH = 4; /* Rename patient as PTID, column width = 4 */ DEFINE gender / DISPLAY FORMAT = gendfmt.; /* Formatting GENDER */ DEFINE height / ANALYSIS &#39;HT&#39; FORMAT = 4.1; /* */ DEFINE weight / ANALYSIS &#39;WT&#39; FORMAT = 4.; DEFINE age / DISPLAY FORMAT = 3.1; DEFINE race / DISPLAY FORMAT = racefmt.; DEFINE drug / DISPLAY WIDTH = 8; TITLE &quot;Basic Report: Column Header Modification&quot;; RUN; /** Example 3: Conditional output **/ ODS HTML; /* We add colors to the table, we need a file destination that can render the colors. The default LISTING destination cannot render the colors specified in the STYLE option.*/ PROC REPORT DATA = DEMOGRAPHICS NOWINDOWS HEADLINE HEADSKIP STYLE(Header)=[Background=White Cellspacing=0 Bordercolor=Blue Borderwidth=2 Rules=rows Frame=box] STYLE(COLUMN)=[Background=Purple Foreground = Gold Cellspacing = 10]; COLUMNS Patient height weight drug ratio; DEFINE patient / WIDTH =7; DEFINE height / ANALYSIS FORMAT = 4.1 WIDTH = 8; DEFINE weight / ANALYSIS FORMAT = 4.0 WIDTH = 8; DEFINE RATIO /COMPUTED &#39;Ratio&#39;; COMPUTE RATIO; IF UPCASE(drug)=&quot;ACTIVE&quot; THEN /* The sum of individual observation is itself! */ /* height.SUM: The extension is required! */ /* height /weight ==&gt; produce error!! */ RATIO = height.SUM/weight.SUM; ENDCOMP; TITLE &quot; STYLE(Hearder)+ Conditional Logic &quot;; RUN; ODS HTML CLOSE; /***************************************************************/ /*** Topic 3: The ODS Destination and Exporting Report ***/ /***************************************************************/ /** Available output STYLES are available in SAS and can be found by running the following PROCedure **/ PROC TEMPLATE ; LIST STYLES ; RUN; /** Example 1: ODS Styles **/ ODS LISTING CLOSE; ODS HTML file = &#39;C:\\STA311\\w13\\Reportmeadow.html&#39; style = meadow; PROC REPORT DATA = DEMOGRAPHICS NOWINDOWS HEADLINE HEADSKIP STYLE(COLUMN)=[Background=Purple Foreground = Gold Cellspacing = 10]; COLUMNS patient gender height weight age race drug; DEFINE patient / DISPLAY &#39;PTID&#39; WIDTH = 4; /* Rename patient as PTID, column width = 4 */ DEFINE gender / DISPLAY FORMAT = gendfmt.; /* Formatting GENDER */ DEFINE height / ANALYSIS &#39;HT&#39; FORMAT = 4.1; /* */ DEFINE weight / ANALYSIS &#39;WT&#39; FORMAT = 4.; DEFINE age / DISPLAY FORMAT = 3.1; DEFINE race / DISPLAY FORMAT = racefmt.; DEFINE drug / DISPLAY WIDTH = 8; TITLE &quot;Basic Report: Column Style&quot;; RUN; ODS HTML CLOSE; ODS LISTING; /** Example 2 **/ /** MACRO for presenting different STYLES **/ %MACRO ODSSTYLE(STYLE = ); ODS HTML FILE =&quot;C:\\STA311\\w13\\REPORT&amp;STYLE..HTML&quot; STYLE =&amp;STYLE; PROC REPORT DATA = DEMOGRAPHICS NOWINDOWS HEADLINE HEADSKIP STYLE(Header)=[Background=White Cellspacing=0 Bordercolor=Blue Borderwidth=2 Rules=rows Frame=box] ; COLUMNS Patient height weight drug ratio; DEFINE patient / WIDTH =7; DEFINE height / ANALYSIS FORMAT = 4.1 WIDTH = 8; DEFINE weight / ANALYSIS FORMAT = 4.0 WIDTH = 8; DEFINE RATIO /COMPUTED &#39;Ratio&#39;; COMPUTE RATIO; IF UPCASE(drug)=&quot;ACTIVE&quot; THEN /* The sum of individual observation is itself! */ /* height.SUM: The extension is required! */ /* height /weight ==&gt; produce error!! */ RATIO = height.SUM/weight.SUM; ENDCOMP; TITLE &quot; STYLE(Header)+ Conditional Logic &quot;; RUN; ODS HTML CLOSE; /* ODS must be closed! */ %MEND; %ODSSTYLE(STYLE=HARVEST); %ODSSTYLE(STYLE=Ocean); %ODSSTYLE(STYLE=MeadowPrinter); %ODSSTYLE(STYLE=PowerPointDark); %ODSSTYLE(STYLE=Excel); %ODSSTYLE(STYLE=BlockPrint); %ODSSTYLE(STYLE=BarrettsBlue); %ODSSTYLE(STYLE=EGDefault); "],["basics-of-sas-macro.html", "Chapter 15 Basics of SAS MACRO 15.1 MACRO Variables 15.2 SAS MACRO 15.3 MACROs with Parameters 15.4 Learning Coding by Examples", " Chapter 15 Basics of SAS MACRO The SAS Macro language is another language that rests on top of regular SAS code. It allows us to assign a name to groups of SAS programming statements. From that point on, we can work with the name rather than with the text itself. Macros are particularly useful if we want to make your SAS programs more flexible and allow them to be used in different situations without having to rewrite entire programs The programmatic role of SAS MACROs is similar to functions/routines in other programming languages. Whenever there are repetitive data and analytic tasks in SAS coding, we need MACROs. SAS MACROs consist of collections of regular SAS program statements, macro variables, macro statements and macro functions that are contained within a %MACRO and a %MEND. 15.1 MACRO Variables SAS MACRO variables can be defined and used anywhere in a SAS program, except data lines (i.e. raw data). A MACRO variable contains one value that remains constant until explicitly changed. We can also consider a MACRO variable as a string replacement method! 15.1.1 Defining MACRO Variables There are a number of SAS system-defined MACRO variables. User-defined MACRO variables are based on the syntax given below. %LET macrovar = value; macrovar: MACRO variable name that follows the regular SAS naming conventions value: any string or macro expression stored as a character type length 0-32k characters Math expressions are not evaluated Quotations not needed Leading/trailing blanks in the value must be removed Examples of MACRO Variables 15.1.2 Use of MACRO Variables To use a macro variable, precede the macro variable name with an ampersand (&amp;), something like &amp;macrovar. &amp;macrovar will be replaced with whatever text was assigned to the MACRO variable. Example We still use the Cars data in the SASHELP library. %LET var_list = Horsepower Invoice MPG_City MSRP; TITLE &quot;Using a Macro Variable List&quot;; PROC MEANS DATA = SASHELP.Cars n mean min max ; VAR &amp;var_list; /* calling MACRO variable */ RUN; In the code, &amp;var_list was replaced with Horsepower, nvoice, MPG_City, MSRP. Example 2 Random number generation. %LET n = 3; DATA generate; DO Subj = 1 TO &amp;n; /* &amp;n = 3 */ x = int(100*RANUNI(0) + 1); /* ranuni(0): 0 is seed */ OUTPUT; END; RUN; The output is 15.1.3 Combining Macro Variables with Text MACRO variables can be appended to text or variable names: varname&amp;macrovar Or prepended: &amp;macrovar.text We need to insert a . between the macro variable and the text so SAS knows where the text begins. Or connected to other macro variables: &amp;macvar1&amp;macvar2 The following example explains the above concept. Example 3 When concatenating a data set to a macro variable containing the libname, you need to use double decimal points instead of one. 15.1.4 Macro Quoting MACRO variables can not resolve single quotes – we must use double quotes. Therefore, we cannot use single quotes in a TITLE whenever calling a MACRO in it. See the following example. 15.1.5 System Automatics MACRO Variables SAS has a few system-automatic MACRO variables we can call for various needs. The next example calls the system time when printing out results from data or procedure steps. 15.2 SAS MACRO “A macro is stored text identified by a name.” It is used for generating repetitive pieces of SAS code; conditionally executing code. The definition of MACRO begins with a %MACRO statement and ends with a %MEND statement. Coding beginning with % signs is evaluated by the macro processor. %MACRO macro-name: begins the macro definition and assigns a name to the macro macro text any text regular SAS statements or steps macro variables, functions, or statements combination of the above %MEND macro-name: ends the macro definition. macro-name is optional. Comments on MACRO Name: A MACRO name must satisfy the following conditions not an SAS statement, therefore, doesn’t require a semi-colon can be placed anywhere in a program except in data lines Submitting a macro definition complies with the macro. If the macro compiles successfully, SAS will run the generated SAS code. There are two major types of MACROs: with and without parameters. The following MACRO does have parameters to pass into. Example 4: MACRO with no parameters to pass in. /* Define MACRO variable*/ %LET a = blood; %LET x = sex; /* Define a MACRO */ %MACRO sortx; PROC SORT DATA = &amp;a; BY &amp;x; RUN; PROC MEANS DATA = &amp;a; BY &amp;x; RUN; %MEND sortx; /* Call MACRO*/ %sortx; 15.3 MACROs with Parameters We can use %LET statement to define a MACRO variable. Another way to define the MACRO variable is to use parameters. Parameters pass variable values to macros in the form of MACRO variables. There are 2 types of parameters: positional keyword 15.3.1 Positional Parameter In positional parametric MACROs, the order of the parameters in the definition of MACRO MUST BE IDENTICAL to the one in the MACRO call. The parameter list is defined in the %MACRO statement and contains names of macro variables referenced only within the macro. To call this macro and provide values for the macro parameters you list the values you want to substitute for each parameter in the macro call statement. Values are substituted for the parameter variables using a one-to-one correspondence. %MACRO macro-name(p1, …, pn); enclosed in parentheses separated with commas Following SAS naming conventions referenced as a macro variable within the macro (&amp;p1, &amp;p2, etc ) Macro call values: %macro-name(v1, …, vn) enclosed in parentheses separated with commas are substituted for the parameters using a one-to-one correspondence v1 ==&gt; p1 Use commas as placeholders to substitute a null value for positional parameters. 15.3.2 Keyword Parameter We have used this type of MACRO when generating styled ODS tables and SG graphics in early chapters. The following pseud-code outlines the definition of this type of MACRO. /* Definition */ %MACRO macro-name (KEY1=, ...,KEYn=); text (data, procedure steps, or other commands, ) %MEND macro-name; /* MACRO call*/ %macro-name (KEY1=val1, ...,KEYn=valn) The keyword parameters are defined in the %MACRO statement. KEYn is the name of the macro variable followed by an =. VALUE is the default value assigned to the macro variable. To call this macro and substitute different values you must indicate the macro variable (KEYn) followed by an = and the value you want to substitute. You can specify keyword parameters in any order. Parameters not defined are assigned the default value. Comments on the Definition: Macro parameters: %MACRO macro-name(KEY1=value, …, KEYn=value); enclosed in parentheses, separated by commas assigned a default value (null is allowed) referred to as a macro variable within the macro (&amp;KEYn) keyword complies with SAS naming conventions Macro call values: %macro-name (KEY1=value, …, KEYn=value) enclosed in parentheses, separated by commas can be null values, text, macro variable references can be listed in any order can be omitted from the call (default used) The example shows the definition of MACRO with parameters and MACRO calls. 15.3.3 Mixed Parameter List Although it is unnecessary to define mixed parametric MACRO from a practical perspective, it is still a valid MACRO. The following pseudo-code defines a MACRO with mixed parameter inputs. %MACRO macro-name (p1, …, pn, key=value, …,key=value); text %MEND macro-name; %macro-name (v1, …, vn, key=value, …, key=value) Note that all positional parameters must be listed in order before any keyword parameters. 15.4 Learning Coding by Examples This section contains more examples of SAS MACROs using direct input small data sets. /********************************************************** Topics 1: Introduction 2: MACRO variable 3: General MACRO 4: MACRO with Parameters ***********************************************************/ OPTIONS PS = 26 LS = 72 NODATE NONUMBER; TITLE &quot;&quot;; FOOTNOTE &quot;&quot;; /** Working Data Set **/ DATA MODELS; INFILE DATALINES; INPUT Model $ 1-12 Class $ Price Frame$ 28-38; DATALINES; Black Bora Track 796 Aluminum Delta Breeze Road 399 CroMoly Jet Stream Track 1130 CroMoly Mistral Road 1995 Carbon Comp Nor&#39;easter Mountain 899 Aluminum Santa Ana Mountain 459 Aluminum Scirocco Mountain 2256 Titanium Trade Wind Road 759 Aluminum ; RUN; /***************************************************************** Topic #1: Introduction Q. What is SAS MACRO? A. A SAS MACRO is a SAS facility of text replacement. There are two SAS MACROs: MACRO variable and MACRO program A SAS MACRO Variable replaces the small scale of texts in SAS programs. A SAS MACRO Program replaces large-scale texts in SAS programs. Macro triggers: &amp; % &amp; - Macro variable resolution % - Macro invocation %LET statement - defining a SAS MACRO variable %MACRO macro_program_name(list of parameters); Text replacement/text filler... %MEND macro_program_name; Note: Macro naming convention - can be up to 32 characters in length. ******************************************************************/ /** Example 1: explicit definition of SAS MACRO variable using %LET statement.**/ %LET my_macro_var1 = 3+4; /* plain text value */ %LET my_macro_var2 = &#39;3+4&#39;; /* string with single quote */ %LET my_macro_var3 = &quot; 3+4 &quot;; /* string with double quote */ /** **/ DATA TEST_MACRO_VAR; my_var = 3 + 4; macro_var1 = &amp;my_macro_var1; /* &amp;my_macro_var1 = 3 + 4 */ macro_var2 = &amp;my_macro_var2; /* &amp;my_macro_var1 = &#39;3+4&#39; */ macro_var3 = &amp;my_macro_var3; /* &amp;my_macro_var1 = &quot;3+4&quot; */ RUN; PROC PRINT DATA = TEST_MACRO_VAR; RUN; PROC CONTENTS DATA = TEST_MACRO_VAR; RUN; /** Example 2: text/string replacement in titles and footnotes **/ /** Calling a macro in a string such as in title and footnote, double quote must be used to resolve the value of the MACRO variable. **/ PROC PRINT DATA = TEST_MACRO_VAR; TITLE1 &quot;1-Calling macro_var1 (single-quote): &amp;my_macro_var1&quot;; TITLE2 &#39;2-Calling macro_var1 (single-quote): &amp;my_macro_var1&#39;; TITLE3 &quot;3-Calling macro_var2 (double-quote): &amp;my_macro_var2&quot;; TITLE4 &#39;4-Calling macro_var2 (single-quote): &amp;my_macro_var2&#39;; TITLE5 &quot;5-Calling macro_var3 (double-quote): &amp;my_macro_var3&quot;; TITLE6 &#39;6-Calling macro_var3 (single-quote): &amp;my_macro_var3&#39;; RUN; /********************************** Topic #2: MACRO Variable ***********************************/ %LET bikeclass = Mountain; /* Definition of MACRO variable */ /** Example 1: Subsetting without using MACRO variable **/ PROC PRINT DATA = models NOOBS; WHERE Class = &#39;Mountain&#39;; FORMAT Price dollar6.; TITLE &quot;Current Models of Mountain Bicycles 01&quot;; RUN; /** Example 2: Use a macro variable - bikeclass **/ PROC PRINT DATA = models NOOBS; WHERE Class = &quot;&amp;bikeclass&quot;; FORMAT Price dollar6.; TITLE &quot;Current Models of &amp;bikeclass Bicycles 02&quot;; RUN; /** Example 3. Make a title macro variable **/ %LET mytitle = STA311 Week #14 SAS Code; PROC PRINT DATA = MODELS; TITLE &amp;mytitle; RUN; /*************************************** Topic 3: MACRO with no Parameter This MACRO is useful when a chunk of code appears repeatedly in the program. The general form of a macro is %MACRO macro-name; macro-text %MEND macro-name; ****************************************/ /** Example 1: When we develop a SAS program, we frequently print out the most created data set to check the correctness of the code. Normally we write a PROC PRINT step to see the content of the most recently created data. We can write a SAS MACRO to avoid writing the PROC PRINT every time. **/ %MACRO printit; /* open the macro statement*/ DM CLEAR OUT; PROC PRINT; TITLE &#39;Most Currently Created Data&#39;; RUN; TITLE &quot;&quot;; %MEND printit; /* close the macro statement*/ /** create a SAS data set and then use %printit to print it out **/ DATA testdat; var1 = 123; var2 = &quot;123&quot;; RUN; %printit; PROC CONTENTS DATA = testdat; RUN; /** Example 2. set of MACRO statements **/ DATA myDATA; INPUT var1 var2 var3; DATALINES; 1 3 6 4 3 9 6 5 2 12 4 5 ; RUN; %printit; /** macro for variable transformation **/ %MACRO comput; var4 = var1 + var2; var5 = var1 - var2; var6 = var1 + var2 + var3; %MEND comput; DATA MyNEWData; SET myDATA; %comput; RUN; %printit; /*********************************** Topic 4: MACRO with parameters ************************************/ /** Think about sorting different variables in the data set and then print it out. For each printout, we want to add titles with information on sorting variables. To avoid writing multiple procedures due to sorting the data with different variables, we can SAS MACRO. Two types of MACRO parameters: Positional and Keyword (1) Positional: %MACRO macro_name(sortseq, sortvar) (2) Keyword: %MACRO macro_name(sortseq =, sortvar =) **/ /** Working Data Set **/ DATA MODELS; INFILE DATALINES; INPUT Model $ 1-12 Class $ Price Frame$ 28-38; DATALINES; Black Bora Track 796 Aluminum Delta Breeze Road 399 CroMoly Jet Stream Track 1130 CroMoly Mistral Road 1995 Carbon Comp Nor&#39;easter Mountain 899 Aluminum Santa Ana Mountain 459 Aluminum Scirocco Mountain 2256 Titanium Trade Wind Road 759 Aluminum ; RUN; /** Example 1: MACRO with positional parameter **/ %MACRO PositionalSortPrint(sortseq, sortvar, out); PROC SORT data = MODELS out = models&amp;out; by &amp;sortseq &amp;sortvar; RUN; PROC PRINT data = models&amp;out noobs; title1 &#39;Current Models:&#39;; title2 &quot;Sorted by &amp;sortseq &amp;sortvar: OUTPUT&amp;out&quot;; var Model Class Frame Price; format price dollar6.; RUN; %MEND PositionalSortPrint; %PositionalSortPrint(DESCENDING, Price, 01) %PositionalSortPrint(Price, DESCENDING, 02) /* order of values were messed up!!!! */ %PositionalSortPrint( , Price, 03) %PositionalSortPrint( , Class, 04) %PositionalSortPrint( DESCENDING, Class, 05) /** Example 2: MACRO with keyword parameter **/ %MACRO KeywordSortPrint(sortseq =, sortvar =, out = ); PROC SORT data = models out = models&amp;out; by &amp;sortseq &amp;sortvar; RUN; PROC PRINT data = models&amp;out noobs; title &#39;Current Models&#39;; title2 &quot;Sorted by &amp;sortseq &amp;sortvar: OUTPUT&amp;out&quot;; var Model Class Frame Price; format price dollar6.; RUN; %MEND KeywordSortPrint; %KeywordSortPrint(sortseq = Descending, sortvar = Price, out = 06) %KeywordSortPrint(sortseq =, sortvar = Price, out = 07) %KeywordSortPrint(sortvar = Price, sortseq = Descending, out = 08) "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
